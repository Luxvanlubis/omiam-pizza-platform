const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');

/**
 * Script de test automatis√© pour le Dashboard Admin O'Miam
 * Valide les analytics avanc√©es et fonctionnalit√©s temps r√©el
 */

class AdminDashboardTester {
  constructor() {
    this.browser = null;
    this.page = null;
    this.results = {
      timestamp: new Date().toISOString(),
      status: 'PENDING',
      tests: [],
      summary: {
        total: 0,
        passed: 0,
        failed: 0,
        warnings: 0
      },
      performance: {},
      screenshots: []
    };
  }

  async init() {
    console.log('üöÄ Initialisation du test Dashboard Admin...');
    
    this.browser = await puppeteer.launch({
      headless: false,
      defaultViewport: { width: 1920, height: 1080 },
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    this.page = await this.browser.newPage();
    
    // Configuration des timeouts et √©v√©nements
    this.page.setDefaultTimeout(30000);
    this.page.setDefaultNavigationTimeout(30000);
    
    // √âcouter les erreurs console
    this.page.on('console', msg => {
      if (msg.type() === 'error') {
        console.log('‚ùå Erreur console:', msg.text());
      }
    });
    
    // √âcouter les erreurs de page
    this.page.on('pageerror', error => {
      console.log('‚ùå Erreur page:', error.message);
    });
  }

  async testDashboardAccess() {
    const testName = 'Acc√®s Dashboard Admin';
    console.log(`\nüìä Test: ${testName}`);
    
    try {
      const startTime = Date.now();
      
      // Navigation vers le dashboard admin
      await this.page.goto('http://localhost:3000/admin/dashboard', {
        waitUntil: 'networkidle2'
      });
      
      const loadTime = Date.now() - startTime;
      
      // V√©rifier le titre de la page
      const title = await this.page.title();
      console.log(`üìÑ Titre de la page: ${title}`);
      
      // V√©rifier la pr√©sence des √©l√©ments principaux
      const dashboardElements = await this.page.evaluate(() => {
        const elements = {
          header: !!document.querySelector('header'),
          navigation: !!document.querySelector('nav'),
          statsCards: document.querySelectorAll('[data-testid*="stat"], .stat-card, [class*="stat"]').length,
          charts: document.querySelectorAll('svg, canvas, [class*="chart"]').length,
          tables: document.querySelectorAll('table, [class*="table"]').length,
          buttons: document.querySelectorAll('button').length
        };
        return elements;
      });
      
      console.log('üìà √âl√©ments d√©tect√©s:', dashboardElements);
      
      // Prendre une capture d'√©cran
      const screenshotPath = path.join(__dirname, '..', 'test-results', `dashboard-${Date.now()}.png`);
      await this.page.screenshot({ path: screenshotPath, fullPage: true });
      this.results.screenshots.push(screenshotPath);
      
      this.results.tests.push({
        name: testName,
        status: 'PASSED',
        duration: loadTime,
        details: {
          loadTime: `${loadTime}ms`,
          title,
          elements: dashboardElements
        }
      });
      
      this.results.performance.dashboardLoad = loadTime;
      this.results.summary.passed++;
      
      console.log(`‚úÖ ${testName} - R√âUSSI (${loadTime}ms)`);
      
    } catch (error) {
      console.log(`‚ùå ${testName} - √âCHEC:`, error.message);
      
      this.results.tests.push({
        name: testName,
        status: 'FAILED',
        error: error.message
      });
      
      this.results.summary.failed++;
    }
    
    this.results.summary.total++;
  }

  async testAnalyticsComponents() {
    const testName = 'Composants Analytics';
    console.log(`\nüìä Test: ${testName}`);
    
    try {
      // Rechercher les composants d'analytics
      const analyticsData = await this.page.evaluate(() => {
        const components = {
          realTimeMetrics: document.querySelectorAll('[class*="real-time"], [data-testid*="real-time"]').length,
          kpiCards: document.querySelectorAll('[class*="kpi"], [class*="metric"], [class*="stat"]').length,
          charts: document.querySelectorAll('svg[class*="recharts"], canvas').length,
          tables: document.querySelectorAll('table, [class*="table"]').length,
          filters: document.querySelectorAll('select, [class*="filter"], [class*="dropdown"]').length,
          tabs: document.querySelectorAll('[role="tab"], [class*="tab"]').length
        };
        
        // V√©rifier la pr√©sence de donn√©es
        const hasData = {
          numbers: document.querySelectorAll('[class*="number"], [class*="value"]').length > 0,
          percentages: /\d+%/.test(document.body.textContent),
          currency: /‚Ç¨|\$/.test(document.body.textContent),
          dates: /\d{1,2}\/\d{1,2}|\d{4}-\d{2}-\d{2}/.test(document.body.textContent)
        };
        
        return { components, hasData };
      });
      
      console.log('üìà Analytics d√©tect√©s:', analyticsData);
      
      // Tester l'interactivit√© des filtres
      const filterElements = await this.page.$$('select, [role="combobox"]');
      if (filterElements.length > 0) {
        console.log(`üîç Test des filtres (${filterElements.length} trouv√©s)`);
        
        for (let i = 0; i < Math.min(filterElements.length, 3); i++) {
          try {
            await filterElements[i].click();
            await this.page.waitForTimeout(500);
            console.log(`‚úÖ Filtre ${i + 1} - Interactif`);
          } catch (e) {
            console.log(`‚ö†Ô∏è Filtre ${i + 1} - Non interactif`);
          }
        }
      }
      
      this.results.tests.push({
        name: testName,
        status: 'PASSED',
        details: analyticsData
      });
      
      this.results.summary.passed++;
      console.log(`‚úÖ ${testName} - R√âUSSI`);
      
    } catch (error) {
      console.log(`‚ùå ${testName} - √âCHEC:`, error.message);
      
      this.results.tests.push({
        name: testName,
        status: 'FAILED',
        error: error.message
      });
      
      this.results.summary.failed++;
    }
    
    this.results.summary.total++;
  }

  async testModuleNavigation() {
    const testName = 'Navigation Modules Admin';
    console.log(`\nüß≠ Test: ${testName}`);
    
    try {
      // Rechercher les onglets/modules disponibles
      const modules = await this.page.evaluate(() => {
        const tabs = Array.from(document.querySelectorAll('[role="tab"], [class*="tab"], button[class*="nav"]'));
        return tabs.map(tab => ({
          text: tab.textContent?.trim() || '',
          visible: tab.offsetParent !== null,
          clickable: !tab.disabled
        })).filter(tab => tab.text.length > 0);
      });
      
      console.log(`üìã Modules d√©tect√©s: ${modules.length}`);
      modules.forEach((module, index) => {
        console.log(`  ${index + 1}. ${module.text} (${module.visible ? 'Visible' : 'Cach√©'}, ${module.clickable ? 'Cliquable' : 'D√©sactiv√©'})`);
      });
      
      // Tester la navigation vers quelques modules
      const testModules = modules.slice(0, 3);
      for (const module of testModules) {
        if (module.clickable && module.visible) {
          try {
            const moduleButton = await this.page.$x(`//button[contains(text(), "${module.text}")]`);
            if (moduleButton.length > 0) {
              await moduleButton[0].click();
              await this.page.waitForTimeout(1000);
              console.log(`‚úÖ Navigation vers "${module.text}" - R√©ussie`);
            }
          } catch (e) {
            console.log(`‚ö†Ô∏è Navigation vers "${module.text}" - Probl√®me:`, e.message);
          }
        }
      }
      
      this.results.tests.push({
        name: testName,
        status: 'PASSED',
        details: { modules, testedModules: testModules.length }
      });
      
      this.results.summary.passed++;
      console.log(`‚úÖ ${testName} - R√âUSSI`);
      
    } catch (error) {
      console.log(`‚ùå ${testName} - √âCHEC:`, error.message);
      
      this.results.tests.push({
        name: testName,
        status: 'FAILED',
        error: error.message
      });
      
      this.results.summary.failed++;
    }
    
    this.results.summary.total++;
  }

  async testPerformanceMetrics() {
    const testName = 'M√©triques de Performance';
    console.log(`\n‚ö° Test: ${testName}`);
    
    try {
      // Mesurer les performances de la page
      const metrics = await this.page.metrics();
      const performanceData = await this.page.evaluate(() => {
        const navigation = performance.getEntriesByType('navigation')[0];
        return {
          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
          loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
          firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime || 0,
          firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0
        };
      });
      
      console.log('üìä M√©triques de performance:');
      console.log(`  - DOM Content Loaded: ${performanceData.domContentLoaded.toFixed(2)}ms`);
      console.log(`  - Load Complete: ${performanceData.loadComplete.toFixed(2)}ms`);
      console.log(`  - First Paint: ${performanceData.firstPaint.toFixed(2)}ms`);
      console.log(`  - First Contentful Paint: ${performanceData.firstContentfulPaint.toFixed(2)}ms`);
      console.log(`  - JS Heap Used: ${(metrics.JSHeapUsedSize / 1024 / 1024).toFixed(2)} MB`);
      
      this.results.performance = {
        ...this.results.performance,
        ...performanceData,
        jsHeapUsed: metrics.JSHeapUsedSize,
        jsHeapTotal: metrics.JSHeapTotalSize
      };
      
      this.results.tests.push({
        name: testName,
        status: 'PASSED',
        details: { ...performanceData, jsHeapUsed: metrics.JSHeapUsedSize }
      });
      
      this.results.summary.passed++;
      console.log(`‚úÖ ${testName} - R√âUSSI`);
      
    } catch (error) {
      console.log(`‚ùå ${testName} - √âCHEC:`, error.message);
      
      this.results.tests.push({
        name: testName,
        status: 'FAILED',
        error: error.message
      });
      
      this.results.summary.failed++;
    }
    
    this.results.summary.total++;
  }

  async generateReport() {
    console.log('\nüìã G√©n√©ration du rapport...');
    
    // D√©terminer le statut global
    if (this.results.summary.failed === 0) {
      this.results.status = 'PASSED';
    } else if (this.results.summary.passed > this.results.summary.failed) {
      this.results.status = 'PARTIAL';
    } else {
      this.results.status = 'FAILED';
    }
    
    // Cr√©er le dossier de r√©sultats s'il n'existe pas
    const resultsDir = path.join(__dirname, '..', 'test-results');
    if (!fs.existsSync(resultsDir)) {
      fs.mkdirSync(resultsDir, { recursive: true });
    }
    
    // Sauvegarder le rapport JSON
    const reportPath = path.join(resultsDir, `admin-dashboard-test-${Date.now()}.json`);
    fs.writeFileSync(reportPath, JSON.stringify(this.results, null, 2));
    
    console.log('\n============================================================');
    console.log('üìä RAPPORT DE TEST - DASHBOARD ADMIN O\'MIAM');
    console.log('============================================================');
    console.log(`üìÖ Date: ${new Date(this.results.timestamp).toLocaleString('fr-FR')}`);
    console.log(`üìà Statut global: ${this.results.status}`);
    console.log(`üìä Tests: ${this.results.summary.total} total, ${this.results.summary.passed} r√©ussis, ${this.results.summary.failed} √©chou√©s`);
    
    if (this.results.performance.dashboardLoad) {
      console.log(`‚ö° Performance: Chargement dashboard ${this.results.performance.dashboardLoad}ms`);
    }
    
    console.log('\nüìã D√©tail des tests:');
    this.results.tests.forEach((test, index) => {
      const status = test.status === 'PASSED' ? '‚úÖ' : '‚ùå';
      console.log(`  ${index + 1}. ${status} ${test.name}`);
      if (test.error) {
        console.log(`     Erreur: ${test.error}`);
      }
    });
    
    console.log(`\nüíæ Rapport sauvegard√©: ${reportPath}`);
    console.log('============================================================');
    
    return this.results;
  }

  async cleanup() {
    if (this.browser) {
      await this.browser.close();
    }
  }

  async run() {
    try {
      await this.init();
      
      // Ex√©cuter tous les tests
      await this.testDashboardAccess();
      await this.testAnalyticsComponents();
      await this.testModuleNavigation();
      await this.testPerformanceMetrics();
      
      // G√©n√©rer le rapport final
      const results = await this.generateReport();
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'ex√©cution des tests:', error);
      throw error;
    } finally {
      await this.cleanup();
    }
  }
}

// Ex√©cution du script
if (require.main === module) {
  const tester = new AdminDashboardTester();
  
  tester.run()
    .then(results => {
      console.log('\nüéâ Tests termin√©s avec succ√®s!');
      process.exit(results.status === 'PASSED' ? 0 : 1);
    })
    .catch(error => {
      console.error('üí• √âchec des tests:', error);
      process.exit(1);
    });
}

module.exports = AdminDashboardTester;