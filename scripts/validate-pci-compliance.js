#!/usr/bin/env node

/**
 * Script de validation PCI DSS (Payment Card Industry Data Security Standard)
 * V√©rifie la conformit√© aux exigences de s√©curit√© pour les paiements
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Configuration des couleurs pour les logs
const colors = { reset: '\x1b[0m', bright: '\x1b[1m', red: '\x1b[31m', green: '\x1b[32m', yellow: '\x1b[33m', blue: '\x1b[34m', magenta: '\x1b[35m', cyan: '\x1b[36m'
};

class PCIComplianceValidator { constructor() { this.results = { tests: [], passed: 0, failed: 0, warnings: 0, critical: 0 }; this.projectRoot = process.cwd(); } log(message, color = 'reset') { const colorCode = colors[color] || colors.reset; console.log(`${colorCode}${message}${colors.reset}`); } addTest(name, status, details = '', severity = 'medium') { const test = { name, status, details, severity, timestamp: new Date().toISOString() }; this.results.tests.push(test); if (status === 'PASS') { this.results.passed++; } else if (status === 'FAIL') { this.results.failed++; if (severity === 'critical') { this.results.critical++; } } else if (status === 'WARN') { this.results.warnings++; } } async fileExists(filePath) { try { await fs.promises.access(path.join(this.projectRoot, filePath)); return true; } catch { return false; } } async readFile(filePath) { try { return await fs.promises.readFile(path.join(this.projectRoot, filePath), 'utf8'); } catch { return null; } } // PCI DSS Requirement 1: Firewall Configuration async validateNetworkSecurity() { this.log('\nüî• PCI DSS Req 1: Configuration r√©seau et firewall...', 'cyan'); // V√©rifier la configuration du middleware de s√©curit√© const middlewareExists = await this.fileExists('src/middleware.ts'); if (middlewareExists) { const middlewareContent = await this.readFile('src/middleware.ts'); if (middlewareContent && middlewareContent.includes('security')) { this.addTest('Network Security Middleware', 'PASS', 'Middleware de s√©curit√© configur√©'); } else { this.addTest('Network Security Middleware', 'WARN', 'Middleware de s√©curit√© basique d√©tect√©'); } } else { this.addTest('Network Security Middleware', 'FAIL', 'Aucun middleware de s√©curit√© trouv√©', 'critical'); } // V√©rifier la configuration Next.js const nextConfigExists = await this.fileExists('next.config.ts'); if (nextConfigExists) { const nextConfig = await this.readFile('next.config.ts'); if (nextConfig && nextConfig.includes('headers')) { this.addTest('Security Headers', 'PASS', 'En-t√™tes de s√©curit√© configur√©s'); } else { this.addTest('Security Headers', 'WARN', 'En-t√™tes de s√©curit√© manquants'); } } // V√©rifier la configuration HTTPS const envContent = await this.readFile('.env.local'); if (envContent) { if (envContent.includes('https://') || envContent.includes('NEXTAUTH_URL=https')) { this.addTest('HTTPS Configuration', 'PASS', 'Configuration HTTPS d√©tect√©e'); } else { this.addTest('HTTPS Configuration', 'WARN', 'Configuration HTTPS recommand√©e pour la production'); } } } // PCI DSS Requirement 2: Default Passwords async validateDefaultSecurity() { this.log('\nüîê PCI DSS Req 2: S√©curit√© par d√©faut...', 'cyan'); const envContent = await this.readFile('.env.local'); const envExampleContent = await this.readFile('.env.example'); let weakPasswords = []; if (envContent) { // Rechercher des mots de passe faibles const weakPatterns = [ /password["'`]?\s*[:=]\s*["'`]?(123|admin|password|test|demo|default)["'`]?/gi, /secret["'`]?\s*[:=]\s*["'`]?(123|admin|password|test|demo|default)["'`]?/gi, /key["'`]?\s*[:=]\s*["'`]?(123|admin|password|test|demo|default)["'`]?/gi ]; weakPatterns.forEach(pattern => { const matches = envContent.match(pattern); if (matches) { weakPasswords.push(...matches); } }); } if (weakPasswords.length === 0) { this.addTest('Default Passwords', 'PASS', 'Aucun mot de passe faible d√©tect√©'); } else { this.addTest('Default Passwords', 'FAIL', `Mots de passe faibles d√©tect√©s: ${weakPasswords.length}`, 'critical'); } // V√©rifier la configuration des sessions if (envContent && envContent.includes('NEXTAUTH_SECRET')) { const secretMatch = envContent.match(/NEXTAUTH_SECRET\s*=\s*(.+)/); if (secretMatch && secretMatch[1].length > 32) { this.addTest('Session Security', 'PASS', 'Secret de session s√©curis√©'); } else { this.addTest('Session Security', 'FAIL', 'Secret de session faible', 'high'); } } else { this.addTest('Session Security', 'WARN', 'Configuration de session manquante'); } } // PCI DSS Requirement 3: Protect Stored Data async validateDataProtection() { this.log('\nüõ°Ô∏è PCI DSS Req 3: Protection des donn√©es stock√©es...', 'cyan'); // V√©rifier le chiffrement des donn√©es sensibles const apiFiles = await this.findFiles('src/app/api', '.ts'); let encryptionFound = false; let sensitiveDataExposed = []; for (const file of apiFiles) { const content = await this.readFile(file); if (content) { // V√©rifier la pr√©sence de chiffrement if (content.includes('encrypt') || content.includes('crypto') || content.includes('bcrypt')) { encryptionFound = true; } // V√©rifier l'exposition de donn√©es sensibles const sensitivePatterns = [ /console\.log\([^)]*(?:password|secret|key|token|card|cvv|ssn)[^)]*\)/gi, /console\.error\([^)]*(?:password|secret|key|token|card|cvv|ssn)[^)]*\)/gi, /res\.json\([^)]*(?:password|secret|key|token)[^)]*\)/gi ]; sensitivePatterns.forEach(pattern => { const matches = content.match(pattern); if (matches) { sensitiveDataExposed.push({ file, matches }); } }); } } if (encryptionFound) { this.addTest('Data Encryption', 'PASS', 'M√©canismes de chiffrement d√©tect√©s'); } else { this.addTest('Data Encryption', 'WARN', 'Aucun chiffrement explicite d√©tect√©'); } if (sensitiveDataExposed.length === 0) { this.addTest('Sensitive Data Exposure', 'PASS', 'Aucune exposition de donn√©es sensibles d√©tect√©e'); } else { this.addTest('Sensitive Data Exposure', 'FAIL', `Exposition potentielle dans ${sensitiveDataExposed.length} fichiers`, 'critical'); } } // PCI DSS Requirement 4: Encrypt Data in Transit async validateTransmissionSecurity() { this.log('\nüîí PCI DSS Req 4: Chiffrement des transmissions...', 'cyan'); // V√©rifier la configuration TLS/SSL const nextConfig = await this.readFile('next.config.ts'); if (nextConfig) { if (nextConfig.includes('https') || nextConfig.includes('ssl')) { this.addTest('TLS Configuration', 'PASS', 'Configuration TLS d√©tect√©e'); } else { this.addTest('TLS Configuration', 'WARN', 'Configuration TLS recommand√©e'); } } // V√©rifier les en-t√™tes de s√©curit√© const middlewareContent = await this.readFile('src/middleware.ts'); if (middlewareContent) { const securityHeaders = [ 'Strict-Transport-Security', 'X-Content-Type-Options', 'X-Frame-Options', 'Content-Security-Policy' ]; const foundHeaders = securityHeaders.filter(header => middlewareContent.includes(header) ); if (foundHeaders.length >= 3) { this.addTest('Security Headers', 'PASS', `${foundHeaders.length}/4 en-t√™tes de s√©curit√© configur√©s`); } else { this.addTest('Security Headers', 'WARN', `Seulement ${foundHeaders.length}/4 en-t√™tes de s√©curit√©`); } } } // PCI DSS Requirement 6: Secure Development async validateSecureDevelopment() { this.log('\nüë®‚Äçüíª PCI DSS Req 6: D√©veloppement s√©curis√©...', 'cyan'); // V√©rifier les vuln√©rabilit√©s communes const vulnerabilities = await this.checkCommonVulnerabilities(); if (vulnerabilities.length === 0) { this.addTest('Common Vulnerabilities', 'PASS', 'Aucune vuln√©rabilit√© commune d√©tect√©e'); } else { this.addTest('Common Vulnerabilities', 'FAIL', `${vulnerabilities.length} vuln√©rabilit√©s d√©tect√©es`, 'critical'); } // V√©rifier la gestion des erreurs const errorHandling = await this.checkErrorHandling(); if (errorHandling.secure) { this.addTest('Error Handling', 'PASS', 'Gestion s√©curis√©e des erreurs'); } else { this.addTest('Error Handling', 'WARN', 'Am√©liorer la gestion des erreurs'); } } // PCI DSS Requirement 8: Access Control async validateAccessControl() { this.log('\nüîë PCI DSS Req 8: Contr√¥le d\'acc√®s...', 'cyan'); // V√©rifier l'authentification const authFiles = await this.findFiles('src', 'auth'); if (authFiles.length > 0) { this.addTest('Authentication System', 'PASS', 'Syst√®me d\'authentification d√©tect√©'); } else { this.addTest('Authentication System', 'WARN', 'Syst√®me d\'authentification recommand√©'); } // V√©rifier les middlewares d'autorisation const middlewareContent = await this.readFile('src/middleware.ts'); if (middlewareContent && middlewareContent.includes('auth')) { this.addTest('Authorization Middleware', 'PASS', 'Middleware d\'autorisation configur√©'); } else { this.addTest('Authorization Middleware', 'WARN', 'Middleware d\'autorisation recommand√©'); } } // PCI DSS Requirement 10: Logging async validateLogging() { this.log('\nüìù PCI DSS Req 10: Journalisation...', 'cyan'); // V√©rifier la journalisation des acc√®s const apiFiles = await this.findFiles('src/app/api', '.ts'); let loggingFound = false; let secureLogging = true; for (const file of apiFiles) { const content = await this.readFile(file); if (content) { if (content.includes('console.log') || content.includes('logger')) { loggingFound = true; } // V√©rifier que les logs ne contiennent pas de donn√©es sensibles const sensitiveInLogs = content.match(/console\.log\([^)]*(?:password|secret|key|token|card|cvv)[^)]*\)/gi); if (sensitiveInLogs) { secureLogging = false; } } } if (loggingFound) { this.addTest('Access Logging', 'PASS', 'Journalisation des acc√®s d√©tect√©e'); } else { this.addTest('Access Logging', 'WARN', 'Journalisation des acc√®s recommand√©e'); } if (secureLogging) { this.addTest('Log Security', 'PASS', 'Journalisation s√©curis√©e'); } else { this.addTest('Log Security', 'WARN', 'Donn√©es sensibles potentiellement expos√©es dans les logs'); } } async findFiles(directory, pattern) { const files = []; try { const entries = await fs.promises.readdir(path.join(this.projectRoot, directory), { withFileTypes: true }); for (const entry of entries) { const fullPath = path.join(directory, entry.name); if (entry.isDirectory()) { const subFiles = await this.findFiles(fullPath, pattern); files.push(...subFiles); } else if (entry.name.includes(pattern)) { files.push(fullPath); } } } catch (error) { // Directory doesn't exist or can't be read } return files; } async checkCommonVulnerabilities() { const vulnerabilities = []; // V√©rifier les vuln√©rabilit√©s Path Traversal const apiFiles = await this.findFiles('src/app/api', '.ts'); for (const file of apiFiles) { const content = await this.readFile(file); if (content) { // Path Traversal if (content.includes('path.join') && !content.includes('validateSecurePath')) { vulnerabilities.push({ type: 'Path Traversal', file }); } // SQL Injection (basic check) if (content.includes('query') && content.includes('${') && !content.includes('prepared')) { vulnerabilities.push({ type: 'SQL Injection', file }); } // XSS (basic check) if (content.includes('innerHTML') || content.includes('dangerouslySetInnerHTML')) { vulnerabilities.push({ type: 'XSS', file }); } } } return vulnerabilities; } async checkErrorHandling() { const apiFiles = await this.findFiles('src/app/api', '.ts'); let hasErrorHandling = false; let exposesErrors = false; for (const file of apiFiles) { const content = await this.readFile(file); if (content) { if (content.includes('try') && content.includes('catch')) { hasErrorHandling = true; } if (content.includes('error.message') || content.includes('error.stack')) { exposesErrors = true; } } } return { secure: hasErrorHandling && !exposesErrors, hasErrorHandling, exposesErrors }; } calculateComplianceScore() { const totalTests = this.results.tests.length; if (totalTests === 0) return 0; const passedTests = this.results.passed; const warningTests = this.results.warnings; // Les tests r√©ussis comptent pour 100%, les avertissements pour 50% const score = ((passedTests + (warningTests * 0.5)) / totalTests) * 100; return Math.round(score); } generateReport() { const complianceScore = this.calculateComplianceScore(); const isCompliant = this.results.failed === 0 && this.results.critical === 0; return { timestamp: new Date().toISOString(), compliance_status: isCompliant ? 'COMPLIANT' : 'NON_COMPLIANT', compliance_score: complianceScore, summary: { total_tests: this.results.tests.length, passed: this.results.passed, failed: this.results.failed, warnings: this.results.warnings, critical_issues: this.results.critical }, tests: this.results.tests, recommendations: this.generateRecommendations(), pci_dss_version: '4.0', validator_version: '1.0.0' }; } generateRecommendations() { const recommendations = []; if (this.results.critical > 0) { recommendations.push({ priority: 'CRITICAL', message: 'R√©soudre tous les probl√®mes critiques pour assurer la conformit√© PCI DSS' }); } if (this.results.failed > 0) { recommendations.push({ priority: 'HIGH', message: 'Corriger les tests √©chou√©s pour am√©liorer la s√©curit√©' }); } if (this.results.warnings > 0) { recommendations.push({ priority: 'MEDIUM', message: 'Examiner et r√©soudre les avertissements de s√©curit√©' }); } return recommendations; } async runValidation() { this.log('üõ°Ô∏è D√©marrage de la validation PCI DSS...', 'magenta'); try { await this.validateNetworkSecurity(); await this.validateDefaultSecurity(); await this.validateDataProtection(); await this.validateTransmissionSecurity(); await this.validateSecureDevelopment(); await this.validateAccessControl(); await this.validateLogging(); const report = this.generateReport(); // Sauvegarder le rapport fs.writeFileSync('pci-compliance-report.json', JSON.stringify(report, null, 2)); this.log('\nüìÑ Rapport de conformit√© sauvegard√©: pci-compliance-report.json', 'blue'); // Afficher le r√©sum√© this.displaySummary(report); // Code de sortie bas√© sur la conformit√© process.exit(report.compliance_status === 'COMPLIANT' ? 0 : 1); } catch (error) { this.log(`‚ùå Erreur lors de la validation: ${error.message}`, 'red'); process.exit(1); } } displaySummary(report) { this.log('\n' + '='.repeat(60), 'cyan'); this.log('üìä R√âSUM√â DE CONFORMIT√â PCI DSS', 'magenta'); this.log('='.repeat(60), 'cyan'); const statusColor = report.compliance_status === 'COMPLIANT' ? 'green' : 'red'; const statusIcon = report.compliance_status === 'COMPLIANT' ? '‚úÖ' : '‚ùå'; this.log(`${statusIcon} Statut: ${report.compliance_status}`, statusColor); this.log(`üìà Score de conformit√©: ${report.compliance_score}%`, 'blue'); this.log(`üìã Tests: ${report.summary.total_tests} total`, 'cyan'); this.log(`‚úÖ R√©ussis: ${report.summary.passed}`, 'green'); this.log(`‚ùå √âchou√©s: ${report.summary.failed}`, 'red'); this.log(`‚ö†Ô∏è  Avertissements: ${report.summary.warnings}`, 'yellow'); this.log(`üö® Critiques: ${report.summary.critical_issues}`, 'red'); if (report.recommendations.length > 0) { this.log('\nüìã Recommandations:', 'yellow'); report.recommendations.forEach(rec => { const icon = rec.priority === 'CRITICAL' ? 'üö®' : rec.priority === 'HIGH' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'; this.log(`${icon} ${rec.message}`, 'yellow'); }); } this.log('\n' + '='.repeat(60), 'cyan'); }
}

// Ex√©cution si appel√© directement
if (require.main === module) { const validator = new PCIComplianceValidator(); validator.runValidation();
}

module.exports = PCIComplianceValidator;