"use client";

import { useState, useEffect, useMemo, useCallback } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Progress } from "@/components/ui/progress";
import { Zap, Database, Clock, BarChart3, Settings, RefreshCw, ChevronLeft, ChevronRight, Eye, EyeOff, Trash2, Download, Upload, Server, Cpu, HardDrive, Wifi, AlertCircle, CheckCircle, TrendingUp, TrendingDown, Activity, MemoryStick
} from "lucide-react";
import { cn } from "@/lib/utils";

// Types pour l'optimisation des performances
interface PerformanceMetric { id: string; name: string; value: number; unit: string; status: 'excellent' | 'good' | 'warning' | 'critical'; trend: 'up' | 'down' | 'stable'; description: string;
}

interface CacheEntry { id: string; : string; size: number; hitCount: number; missCount: number; lastAccessed: Date; ttl: number; type: 'memory' | 'redis' | 'database';
}

interface DatabaseQuery { id: string; query: string; executionTime: number; frequency: number; lastExecuted: Date; status: 'optimized' | 'slow' | 'critical'; suggestions: string[];
}

interface OptimizationSettings { caching: { enabled: boolean; ttl: number; maxSize: number; strategy: 'lru' | 'lfu' | 'fifo'; }; lazyLoading: { enabled: boolean; threshold: number; batchSize: number; }; compression: { enabled: boolean; level: number; types: string[]; }; database: { connectionPoolSize: number; queryTimeout: number; indexOptimization: boolean; };
}

// Données simulées
const mockMetrics: PerformanceMetric[] = [ { id: '1', name: 'Temps de réponse API', value: 245, unit: 'ms', status: 'good', trend: 'down', description: 'Temps moyen de réponse des API' }, { id: '2', name: 'Utilisation CPU', value: 68, unit: '%', status: 'warning', trend: 'up', description: 'Utilisation moyenne du processeur' }, { id: '3', name: 'Utilisation mémoire', value: 42, unit: '%', status: 'good', trend: 'stable', description: 'Utilisation de la mémoire RAM' }, { id: '4', name: 'Taux de cache hit', value: 89, unit: '%', status: 'excellent', trend: 'up', description: 'Pourcentage de requêtes servies par le cache' }, { id: '5', name: 'Requêtes DB/sec', value: 156, unit: 'req/s', status: 'good', trend: 'stable', description: 'Nombre de requêtes base de données par seconde' }, { id: '6', name: 'Temps de chargement page', value: 1.8, unit: 's', status: 'good', trend: 'down', description: 'Temps moyen de chargement des pages' }
];

const mockCacheEntries: CacheEntry[] = [ { id: '1', : 'menu_items_all', size: 2048, hitCount: 1245, missCount: 23, lastAccessed: new Date(Date.now() - 5 * 60 * 1000), ttl: 3600, type: 'memory' }, { id: '2', : 'user_sessions', size: 8192, hitCount: 892, missCount: 156, lastAccessed: new Date(Date.now() - 2 * 60 * 1000), ttl: 1800, type: 'redis' }, { id: '3', : 'order_analytics', size: 4096, hitCount: 567, missCount: 89, lastAccessed: new Date(Date.now() - 10 * 60 * 1000), ttl: 7200, type: 'database' }
];

const mockQueries: DatabaseQuery[] = [ { id: '1', query: 'SELECT * FROM orders WHERE status = ? ORDER BY created_at DESC', executionTime: 45, frequency: 234, lastExecuted: new Date(Date.now() - 30 * 1000), status: 'optimized', suggestions: ['Index sur status', 'Pagination recommandée'] }, { id: '2', query: 'SELECT COUNT(*) FROM menu_items JOIN categories ON...', executionTime: 892, frequency: 67, lastExecuted: new Date(Date.now() - 2 * 60 * 1000), status: 'slow', suggestions: ['Optimiser la jointure', 'Ajouter un index composé', 'Utiliser une vue matérialisée'] }, { id: '3', query: 'SELECT * FROM users WHERE email ~ '@' AND email_domain = $1', executionTime: 1245, frequency: 12, lastExecuted: new Date(Date.now() - 5 * 60 * 1000), status: 'critical', suggestions: ['✅ Requête sécurisée avec regex', 'Index sur email_domain ajouté', 'Validation email côté client'] }
];

const defaultSettings: OptimizationSettings = { caching: { enabled: true, ttl: 3600, maxSize: 100, strategy: 'lru' }, lazyLoading: { enabled: true, threshold: 100, batchSize: 20 }, compression: { enabled: true, level: 6, types: ['json', 'html', 'css', 'js'] }, database: { connectionPoolSize: 10, queryTimeout: 30000, indexOptimization: true }
};

export function PerformanceOptimization() { const [metrics, setMetrics] = useState<PerformanceMetric[]>(mockMetrics); const [cacheEntries, setCacheEntries] = useState<CacheEntry[]>(mockCacheEntries); const [queries, setQueries] = useState<DatabaseQuery[]>(mockQueries); const [settings, setSettings] = useState<OptimizationSettings>(defaultSettings); const [isLoading, setIsLoading] = useState(false); const [currentPage, setCurrentPage] = useState(1); const [itemsPerPage] = useState(10); const [searchQuery, setSearchQuery] = useState(""); // Pagination logic const totalPages = Math.ceil(queries.length / itemsPerPage); const startIndex = (currentPage - 1) * itemsPerPage; const endIndex = startIndex + itemsPerPage; const currentQueries = queries.slice(startIndex, endIndex); const handleRefresh = useCallback(async () => { setIsLoading(true); await new Promise(resolve => setTimeout(resolve, 1500)); setIsLoading(false); }, []); const handleClearCache = useCallback((cacheId: string) => { setCacheEntries(prev => prev.filter(entry => entry.id !== cacheId)); }, []); const handleOptimizeQuery = useCallback((queryId: string) => { setQueries(prev => prev.map(query => query.id === queryId ? { ...query, status: 'optimized' as const, executionTime: Math.max(10, query.executionTime * 0.3) } : query )); }, []); const getMetricStatusColor = (status: PerformanceMetric['status']) => { switch (status) { case 'excellent': return 'text-green-600 bg-green-100 dark:bg-green-900/20'; case 'good': return 'text-blue-600 bg-blue-100 dark:bg-blue-900/20'; case 'warning': return 'text-yellow-600 bg-yellow-100 dark:bg-yellow-900/20'; case 'critical': return 'text-red-600 bg-red-100 dark:bg-red-900/20'; default: return 'text-gray-600 bg-gray-100 dark:bg-gray-900/20'; } }; const getTrendIcon = (trend: PerformanceMetric['trend']) => { switch (trend) { case 'up': return <TrendingUp className="h-4 w-4 text-green-600" />; case 'down': return <TrendingDown className="h-4 w-4 text-red-600" />; case 'stable': return <Activity className="h-4 w-4 text-gray-600" />; default: return null; } }; const getQueryStatusColor = (status: DatabaseQuery['status']) => { switch (status) { case 'optimized': return 'text-green-600'; case 'slow': return 'text-yellow-600'; case 'critical': return 'text-red-600'; default: return 'text-gray-600'; } }; const getCacheTypeIcon = (type: CacheEntry['type']) => { switch (type) { case 'memory': return <MemoryStick className="h-4 w-4 text-blue-600" />; case 'redis': return <Server className="h-4 w-4 text-red-600" />; case 'database': return <Database className="h-4 w-4 text-green-600" />; default: return <HardDrive className="h-4 w-4 text-gray-600" />; } }; const formatBytes = (bytes: number) => { if (bytes === 0) return '0 B'; const k = 1024; const sizes = ['B', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]; }; const formatTimestamp = (timestamp: Date) => { return new Intl.DateTimeFormat('fr-FR', { dayle: 'short', timeStyle: 'medium' }).format(timestamp); }; return ( <div className="space-y-6" data-id="performance-optimization"> <div className="flex items-center justify-between"> <div> <h2 className="text-2xl font-bold text-red-800 dark:text-red-600 flex items-center gap-2"> <Zap className="h-6 w-6" /> Optimisation des Performances </h2> <p className="text-muted-foreground">Monitoring et optimisation des performances système</p> </div> <div className="flex items-center gap-3"> <Button variant="outline" onClick={handleRefresh} disabled={isLoading} data-id="refresh-performance" > <RefreshCw className={cn("h-4 w-4 mr-2", isLoading && "animate-spin")} /> Actualiser </Button> </div> </div> <Tabs defaultValue="metrics" className="space-y-6"> <TabsList className="grid w-full grid-cols-4"> <TabsTrigger value="metrics" data-id="tab-metrics">Métriques</TabsTrigger> <TabsTrigger value="cache" data-id="tab-cache">Cache</TabsTrigger> <TabsTrigger value="database" data-id="tab-database">Base de données</TabsTrigger> <TabsTrigger value="settings" data-id="tab-perf-settings">Paramètres</TabsTrigger> </TabsList> <TabsContent value="metrics" className="space-y-6"> <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"> {metrics.map((metric) => ( <Card ={metric.id} className="relative overflow-hidden"> <CardHeader className="pb-3"> <div className="flex items-center justify-between"> <CardTitle className="text-sm font-medium text-muted-foreground"> {metric.name} </CardTitle> {getTrendIcon(metric.trend)} </div> </CardHeader> <CardContent> <div className="flex items-center justify-between mb-2"> <div className="text-2xl font-bold"> {metric.value}{metric.unit} </div> <Badge className={cn("text-xs", getMetricStatusColor(metric.status))}> {metric.status.toUpperCase()} </Badge> </div> <p className="text-xs text-muted-foreground">{metric.description}</p> {/* Progress bar pour les pourcentages */} {metric.unit === '%' && ( <div className="mt-3"> <Progress value={metric.value} className="h-2" data-id={`metric-progress-${metric.id}`} /> </div> )} </CardContent> </Card> ))} </div> </TabsContent> <TabsContent value="cache" className="space-y-6"> <Card> <CardHeader> <div className="flex items-center justify-between"> <div> <CardTitle className="flex items-center gap-2"> <Database className="h-5 w-5 text-red-600" /> Gestion du cache </CardTitle> <CardDescription>Monitoring et gestion des entrées de cache</CardDescription> </div> <Button variant="outline" size="sm" data-id="clear-all-cache"> <Trash2 className="h-4 w-4 mr-1" /> Vider tout </Button> </div> </CardHeader> <CardContent> <div className="space-y-4"> {cacheEntries.map((entry) => { const hitRate = (entry.hitCount / (entry.hitCount + entry.missCount)) * 100; return ( <div ={entry.id} className="flex items-center justify-between p-4 border rounded-lg hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"> <div className="flex items-center gap-4"> {getCacheTypeIcon(entry.type)} <div> <h4 className="font-semibold">{entry.}</h4> <div className="flex items-center gap-4 text-sm text-muted-foreground"> <span>Taille: {formatBytes(entry.size)}</span> <span>Hit rate: {hitRate.toFixed(1)}%</span> <span>TTL: {entry.ttl}s</span> </div> <p className="text-xs text-muted-foreground mt-1"> Dernier accès: {formatTimestamp(entry.lastAccessed)} </p> </div> </div> <div className="flex items-center gap-2"> <div className="text-right text-sm"> <div className="text-green-600 font-medium">{entry.hitCount} hits</div> <div className="text-red-600">{entry.missCount} miss</div> </div> <Button variant="outline" size="sm" onClick={() => handleClearCache(entry.id)} data-id={`clear-cache-${entry.id}`} > <Trash2 className="h-3 w-3" /> </Button> </div> </div> ); })} </div> </CardContent> </Card> </TabsContent> <TabsContent value="database" className="space-y-6"> <Card> <CardHeader> <div className="flex items-center justify-between"> <div> <CardTitle className="flex items-center gap-2"> <Database className="h-5 w-5 text-red-600" /> Requêtes base de données </CardTitle> <CardDescription>Analyse et optimisation des requêtes lentes</CardDescription> </div> <div className="flex items-center gap-2"> <Button variant="outline" size="sm" data-id="export-queries"> <Download className="h-4 w-4 mr-1" /> Exporter </Button> </div> </div> </CardHeader> <CardContent> <div className="space-y-4"> {currentQueries.map((query) => ( <div ={query.id} className="border rounded-lg p-4 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"> <div className="flex items-start justify-between mb-3"> <div className="flex-1"> <div className="flex items-center gap-2 mb-2"> <Badge className={cn("text-xs", getQueryStatusColor(query.status))}> {query.status.toUpperCase()} </Badge> <span className="text-sm text-muted-foreground"> {query.executionTime}ms • {query.frequency} exécutions </span> </div> <code className="text-sm bg-gray-100 dark:bg-gray-800 p-2 rounded block overflow-x-auto"> {query.query} </code> </div> <div className="flex items-center gap-2 ml-4"> {query.status !== 'optimized' && ( <Button variant="outline" size="sm" onClick={() => handleOptimizeQuery(query.id)} data-id={`optimize-query-${query.id}`} > <Zap className="h-3 w-3 mr-1" /> Optimiser </Button> )} <Button variant="outline" size="sm" data-id={`analyze-query-${query.id}`}> <Eye className="h-3 w-3" /> </Button> </div> </div> {query.suggestions.length > 0 && ( <div className="mt-3 p-3 bg-blue-50 dark:bg-blue-900/20 rounded"> <h5 className="text-sm font-medium text-blue-800 dark:text-blue-600 mb-2"> Suggestions d'optimisation: </h5> <ul className="text-sm text-blue-700 dark:text-blue-500 space-y-1"> {query.suggestions.map((suggestion, index) => ( <li ={index} className="flex items-center gap-2"> <CheckCircle className="h-3 w-3" /> {suggestion} </li> ))} </ul> </div> )} </div> ))} </div> {/* Pagination */} <div className="flex items-center justify-between mt-6"> <div className="text-sm text-muted-foreground"> Affichage {startIndex + 1}-{Math.min(endIndex, queries.length)} sur {queries.length} requêtes </div> <div className="flex items-center gap-2"> <Button variant="outline" size="sm" onClick={() => setCurrentPage(prev => Math.max(1, prev - 1))} disabled={currentPage === 1} data-id="prev-page" > <ChevronLeft className="h-4 w-4" /> </Button> <span className="text-sm font-medium"> {currentPage} / {totalPages} </span> <Button variant="outline" size="sm" onClick={() => setCurrentPage(prev => Math.min(totalPages, prev + 1))} disabled={currentPage === totalPages} data-id="next-page" > <ChevronRight className="h-4 w-4" /> </Button> </div> </div> </CardContent> </Card> </TabsContent> <TabsContent value="settings" className="space-y-6"> <div className="grid md:grid-cols-2 gap-6"> <Card> <CardHeader> <CardTitle className="flex items-center gap-2"> <Database className="h-5 w-5 text-red-600" /> Configuration du cache </CardTitle> </CardHeader> <CardContent className="space-y-4"> <div className="flex items-center justify-between"> <Label>Cache activé</Label> <Switch checked={settings.caching.enabled} onCheckedChange={(checked) => setSettings(prev => ({ ...prev, caching: { ...prev.caching, enabled: checked } }))} data-id="toggle-cache" /> </div> <div className="space-y-2"> <Label>TTL par défaut (secondes)</Label> <Input type="number" value={settings.caching.ttl} onChange={(e) => setSettings(prev => ({ ...prev, caching: { ...prev.caching, ttl: parseInt(e.target.value) } }))} data-id="cache-ttl" /> </div> <div className="space-y-2"> <Label>Taille max (MB)</Label> <Input type="number" value={settings.caching.maxSize} onChange={(e) => setSettings(prev => ({ ...prev, caching: { ...prev.caching, maxSize: parseInt(e.target.value) } }))} data-id="cache-max-size" /> </div> <div className="space-y-2"> <Label>Stratégie d'éviction</Label> <Select value={settings.caching.strategy} onValueChange={(value: 'lru' | 'lfu' | 'fifo') => setSettings(prev => ({ ...prev, caching: { ...prev.caching, strategy: value } }))} > <SelectTrigger data-id="cache-strategy"> <SelectValue /> </SelectTrigger> <SelectContent> <SelectItem value="lru">LRU (Least Recently Used)</SelectItem> <SelectItem value="lfu">LFU (Least Frequently Used)</SelectItem> <SelectItem value="fifo">FIFO (First In, First Out)</SelectItem> </SelectContent> </Select> </div> </CardContent> </Card> <Card> <CardHeader> <CardTitle className="flex items-center gap-2"> <Eye className="h-5 w-5 text-red-600" /> Lazy Loading </CardTitle> </CardHeader> <CardContent className="space-y-4"> <div className="flex items-center justify-between"> <Label>Lazy loading activé</Label> <Switch checked={settings.lazyLoading.enabled} onCheckedChange={(checked) => setSettings(prev => ({ ...prev, lazyLoading: { ...prev.lazyLoading, enabled: checked } }))} data-id="toggle-lazy-loading" /> </div> <div className="space-y-2"> <Label>Seuil de déclenchement (px)</Label> <Input type="number" value={settings.lazyLoading.threshold} onChange={(e) => setSettings(prev => ({ ...prev, lazyLoading: { ...prev.lazyLoading, threshold: parseInt(e.target.value) } }))} data-id="lazy-threshold" /> </div> <div className="space-y-2"> <Label>Taille des lots</Label> <Input type="number" value={settings.lazyLoading.batchSize} onChange={(e) => setSettings(prev => ({ ...prev, lazyLoading: { ...prev.lazyLoading, batchSize: parseInt(e.target.value) } }))} data-id="lazy-batch-size" /> </div> </CardContent> </Card> </div> <div className="flex justify-end"> <Button data-id="save-performance-settings"> <Settings className="h-4 w-4 mr-2" /> Sauvegarder les paramètres </Button> </div> </TabsContent> </Tabs> </div> );
}