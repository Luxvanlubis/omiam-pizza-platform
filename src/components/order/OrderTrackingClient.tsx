"use client";

import { useState, useEffect } from "react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Clock, ChefHat, Flame, CheckCircle, Truck, Bell, MessageSquare, Eye, Send, Timer, MapPin, Phone, User, Pizza, AlertCircle, RefreshCw, Share2
} from "lucide-react";

interface OrderStatus { id: string; orderId: string; status: 'pending' | 'confirmed' | 'preparing' | 'cooking' | 'ready' | 'delivered' | 'cancelled'; estimatedTime?: number; actualTime?: number; updatedAt: string; message?: string; employee?: string;
}

interface OrderMessage { id: string; orderId: string; type: 'status_update' | 'info' | 'delay' | 'issue'; message: string; timestamp: string; sender: 'system' | 'employee'; employeeName?: string;
}

interface OrderTrackingData { order: { id: string; customerName: string; customerPhone: string; items: Array<{ name: string; quantity: number; price: number; }>; total: number; deliveryMethod: 'pickup' | 'delivery'; deliveryAddress?: string; specialInstructions?: string; }; status: OrderStatus; messages: OrderMessage[]; timeline: Array<{ status: string; timestamp: string; description: string; employee?: string; }>;
}

const statusOptions = [ { value: "pending", label: "En attente", icon: Clock, color: "bg-gray-100 text-gray-800", description: "Votre commande est en attente de confirmation" }, { value: "confirmed", label: "Confirmée", icon: CheckCircle, color: "bg-blue-100 text-blue-800", description: "Votre commande a été confirmée par notre équipe" }, { value: "preparing", label: "En préparation", icon: ChefHat, color: "bg-yellow-100 text-yellow-800", description: "Notre chef prépare votre commande avec soin" }, { value: "cooking", label: "En cuisson", icon: Flame, color: "bg-orange-100 text-orange-800", description: "Votre pizza est en train de cuire dans notre four à bois" }, { value: "ready", label: "Prête", icon: Pizza, color: "bg-green-100 text-green-800", description: "Votre commande est prête à être retirée ou livrée" }, { value: "delivered", label: "Livrée", icon: Truck, color: "bg-purple-100 text-purple-800", description: "Votre commande a été livrée avec succès" }, { value: "cancelled", label: "Annulée", icon: AlertCircle, color: "bg-red-100 text-red-800", description: "Votre commande a été annulée" }
];

const messageTypes = [ { value: "status_update", label: "Mise à jour", color: "bg-blue-100 text-blue-800" }, { value: "info", label: "Information", color: "bg-green-100 text-green-800" }, { value: "delay", label: "Retard", color: "bg-yellow-100 text-yellow-800" }, { value: "issue", label: "Problème", color: "bg-red-100 text-red-800" }
];

// Simuler les données de commande pour la démo
const mockOrderData: OrderTrackingData = { order: { id: "ORD-001", customerName: "Marie Dupont", customerPhone: "+33 6 12 34 56 78", items: [ { name: "Margherita Royale", quantity: 1, price: 12 }, { name: "Coca-Cola", quantity: 2, price: 3 } ], total: 18, deliveryMethod: "delivery", deliveryAddress: "123 Rue de la Pizza, 75001 Paris", specialInstructions: "Sans champignons s'il vous plaît" }, status: { id: "status-001", orderId: "ORD-001", status: "cooking", estimatedTime: 25, actualTime: 20, updatedAt: "2024-01-15T15:30:00Z", employee: "Chef Marco" }, messages: [ { id: "msg-001", orderId: "ORD-001", type: "status_update", message: "Commande confirmée et en préparation", timestamp: "2024-01-15T15:15:00Z", sender: "system" }, { id: "msg-002", orderId: "ORD-001", type: "info", message: "Votre pizza est en cours de cuisson dans notre four à bois", timestamp: "2024-01-15T15:25:00Z", sender: "employee", employeeName: "Chef Marco" } ], timeline: [ { status: "pending", timestamp: "2024-01-15T15:10:00Z", description: "Commande reçue" }, { status: "confirmed", timestamp: "2024-01-15T15:12:00Z", description: "Commande confirmée", employee: "Service client" }, { status: "preparing", timestamp: "2024-01-15T15:15:00Z", description: "En préparation", employee: "Chef Marco" }, { status: "cooking", timestamp: "2024-01-15T15:25:00Z", description: "En cuisson", employee: "Chef Marco" } ]
};

export function OrderTrackingClient() { const [orderData, setOrderData] = useState<OrderTrackingData | null>(null); const [orderId, setOrderId] = useState(""); const [customerPhone, setCustomerPhone] = useState(""); const [isLoading, setIsLoading] = useState(false); const [newMessage, setNewMessage] = useState(""); const [lastUpdate, setLastUpdate] = useState<Date>(new Date()); // Simuler la connexion WebSocket pour les mises à jour en temps réel useEffect(() => { if (orderData) { const interval = setInterval(() => { // Simuler une mise à jour de statut const randomUpdate = Math.random(); if (randomUpdate > 0.8) { simulaatusUpdate(); } }, 10000); // Vérifier toutes les 10 secondes return () => clearInterval(interval); } }, [orderData]); // Simuler les notifications du navigateur useEffect(() => { if (orderData && "Notification" in window) { // Demander la permission pour les notifications if (Notification.permission === "default") { Notification.requestPermission(); } } }, [orderData]); const handleOrderLookup = async () => { if (!orderId.trim() || !customerPhone.trim()) return; setIsLoading(true); // Simuler un appel API setTimeout(() => { // Pour la démo, on utilise les données mockées setOrderData(mockOrderData); setIsLoading(false); setLastUpdate(new Date()); }, 1500); }; const simulaatusUpdate = () => { if (!orderData) return; const statusFlow: OrderStatus['status'][] = ['pending', 'confirmed', 'preparing', 'cooking', 'ready', 'delivered']; const currentIndex = statusFlow.indexOf(orderData.status.status); if (currentIndex < statusFlow.length - 1) { const nextStatus = statusFlow[currentIndex + 1]; const updatedOrderData: OrderTrackingData = { ...orderData, status: { ...orderData.status, status: nextStatus, updatedAt: new Date().toISOString(), actualTime: orderData.status.actualTime ? orderData.status.actualTime + 5 : 5 }, timeline: [ ...orderData.timeline, { status: nextStatus, timestamp: new Date().toISOString(), description: getStatusDescription(nextStatus), employee: "Équipe O'Miam" } ] }; setOrderData(updatedOrderData); setLastUpdate(new Date()); // Envoyer une notification de navigateur if (Notification.permission === "granted") { new Notification("Mise à jour de votre commande O'Miam", { body: `Votre commande est maintenant : ${statusOptions.find(s => s.value === nextStatus)?.label}`, icon: "/favicon.ico" }); } } }; const getStatusDescription = (status: string) => { const option = statusOptions.find(opt => opt.value === status); return option?.description"Statut inconnu"; }; const getStatusIcon = (status: string) => { const option = statusOptions.find(opt => opt.value === status); return option ? option.icon : Clock; }; const getStatusColor = (status: string) => { const option = statusOptions.find(opt => opt.value === status); return option ? option.color : "bg-gray-100 text-gray-800"; }; const formatTime = (daring: string) => { return new Date(daring).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }); }; const formatDateTime = (daring: string) => { return new Date(daring).toLocaleString('fr-FR', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' }); }; const calculateProgress = (status: string) => { const progressMap = { pending: 0, confirmed: 20, preparing: 40, cooking: 60, ready: 80, delivered: 100, cancelled: 0 }; return progressMap[status as of typeof progressMap] || 0; }; const calculateRemainingTime = () => { if (!orderData || !orderData.status.estimatedTime || !orderData.status.actualTime) { return null; } const remaining = orderData.status.estimatedTime - orderData.status.actualTime; return Math.max(0, remaining); }; const handleShareTracking = () => { if (navigator.share) { navigator.share({ title: 'Suivi de commande O\'Miam', text: `Suivez ma commande ${orderData?.order.id} en temps réel !`, url: window.location.href }); } else { // Fallback: copier dans le presse-papiers navigator.clipboard.writeText(window.location.href); alert('Lien de suivi copié dans le presse-papiers !'); } }; const handleSendMessage = () => { if (!newMessage.trim() || !orderData) return; const newMessageObj: OrderMessage = { id: `msg-${Date.now()}`, orderId: orderData.order.id, type: "info", message: newMessage, timestamp: new Date().toISOString(), sender: "employee" }; setOrderData(prev => prev ? { ...prev, messages: [...prev.messages, newMessageObj] } : null); setNewMessage(""); }; if (!orderData) { return ( <div className="min-h-screen bg-gradient-to-br from-red-50 to-orange-50 flex items-center justify-center p-4"> <Card className="w-full max-w-md"> <CardHeader className="text-center"> <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4"> <Pizza className="h-8 w-8 text-red-600" /> </div> <CardTitle className="text-2xl text-red-800">Suivi de Commande</CardTitle> <CardDescription> Suivez votre commande O'Miam en temps réel </CardDescription> </CardHeader> <CardContent className="space-y-4"> <div> <Label htmlFor="order-id">Numéro de commande</Label> <Input id="order-id" value={orderId} onChange={(e) => setOrderId(e.target.value)} placeholder="ex: ORD-001" /> </div> <div> <Label htmlFor="customer-phone">Numéro de téléphone</Label> <Input id="customer-phone" value={customerPhone} onChange={(e) => setCustomerPhone(e.target.value)} placeholder="+33 6 12 34 56 78" type="tel" /> </div> <Button onClick={handleOrderLookup} disabled={!orderId.trim() || !customerPhone.trim() || isLoading} className="w-full bg-red-600 hover:bg-red-700" > {isLoading ? ( <RefreshCw className="h-4 w-4 mr-2 animate-spin" /> ) : ( <Eye className="h-4 w-4 mr-2" /> )} {isLoading ? "Recherche..." : "Suivre ma commande"} </Button> </CardContent> </Card> </div> ); } const remainingTime = calculateRemainingTime(); return ( <div className="min-h-screen bg-gradient-to-br from-red-50 to-orange-50"> <div className="container mx-auto px-4 py-8"> {/* Header */} <div className="text-center mb-8"> <div className="w-20 h-20 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4"> <Pizza className="h-10 w-10 text-red-600" /> </div> <h1 className="text-3xl font-bold text-red-800 mb-2">Suivi de Commande</h1> <p className="text-lg text-muted-foreground"> Commande {orderData.order.id} • {orderData.order.customerName} </p> <div className="flex items-center justify-center gap-4 mt-4 text-sm text-muted-foreground"> <span>Dernière mise à jour: {formatTime(lastUpdate.toISOString())}</span> <Button size="sm" variant="outline" onClick={handleShareTracking}> <Share2 className="h-3 w-3 mr-1" /> Partager </Button> </div> </div> <div className="grid lg:grid-cols-3 gap-6"> {/* Main Tracking Card */} <div className="lg:col-span-2 space-y-6"> {/* Status Card */} <Card> <CardHeader> <div className="flex justify-between items-start"> <div> <CardTitle className="text-xl">Statut de votre commande</CardTitle> <CardDescription>Suivez l\'avancement en temps réel</CardDescription> </div> <Badge className={getStatusColor(orderData.status.status)}> {(() => { const Icon = getStatusIcon(orderData.status.status); return <Icon className="h-4 w-4 mr-1" />; })()} {statusOptions.find(s => s.value === orderData.status.status)?.label} </Badge> </div> </CardHeader> <CardContent className="space-y-6"> {/* Progress Bar */} <div className="space-y-3"> <div className="flex justify-between text-sm"> <span>Progression</span> <span>{calculateProgress(orderData.status.status)}%</span> </div> <div className="w-full bg-gray-200 rounded-full h-3"> <div className="bg-gradient-to-r from-red-600 to-orange-600 h-3 rounded-full transition-all duration-1000" style={{ width: `${calculateProgress(orderData.status.status)}%` }} /> </div> </div> {/* Status Description */} <div className="bg-blue-50 p-4 rounded-lg"> <div className="flex items-start gap-3"> {(() => { const Icon = getStatusIcon(orderData.status.status); return <Icon className="h-5 w-5 text-blue-600 mt-0.5" />; })()} <div> <p className="font-medium text-blue-800"> {statusOptions.find(s => s.value === orderData.status.status)?.label} </p> <p className="text-sm text-blue-700"> {getStatusDescription(orderData.status.status)} </p> </div> </div> </div> {/* Time Information */} {remainingTime !== null && ( <div className="grid grid-cols-2 gap-4"> <div className="bg-orange-50 p-4 rounded-lg text-center"> <Timer className="h-6 w-6 text-orange-600 mx-auto mb-2" /> <p className="text-sm text-orange-700">Temps restant estimé</p> <p className="text-2xl font-bold text-orange-800">{remainingTime} min</p> </div> <div className="bg-green-50 p-4 rounded-lg text-center"> <Clock className="h-6 w-6 text-green-600 mx-auto mb-2" /> <p className="text-sm text-green-700">Temps écoulé</p> <p className="text-2xl font-bold text-green-800">{orderData.status.actualTime} min</p> </div> </div> )} </CardContent> </Card> {/* Timeline */} <Card> <CardHeader> <CardTitle>Historique de la commande</CardTitle> <CardDescription>Chaque étape de votre commande</CardDescription> </CardHeader> <CardContent> <div className="relative"> <div className="absolute left-4 top-0 bottom-0 w-0.5 bg-gray-200"></div> <div className="space-y-6"> {statusOptions.map((status, index) => { const isActive = orderData.timeline.some(event => event.status === status.value); const isCurrent = orderData.status.status === status.value; const timelineEvent = orderData.timeline.find(event => event.status === status.value); return ( <div ={status.value} className="flex items-center gap-4"> <div className={`w-8 h-8 rounded-full flex items-center justify-center z-10 transition-all duration-500 ${ isActive ? isCurrent ? 'bg-red-600 text-white ring-4 ring-red-200' : 'bg-green-600 text-white' : 'bg-gray-200 text-gray-400' }`}> <status.icon className="h-4 w-4" /> </div> <div className="flex-1"> <div className="flex items-center gap-2"> <span className={`font-medium ${isCurrent ? 'text-red-600' : isActive ? 'text-green-600' : 'text-gray-400'}`}> {status.label} </span> {timelineEvent && ( <span className="text-sm text-muted-foreground"> {formatTime(timelineEvent.timestamp)} </span> )} </div> <p className={`text-sm ${isActive ? 'text-foreground' : 'text-muted-foreground'}`}> {status.description} </p> {timelineEvent?.employee && ( <p className="text-xs text-muted-foreground"> Par: {timelineEvent.employee} </p> )} </div> </div> ); })} </div> </div> </CardContent> </Card> {/* Messages */} <Card> <CardHeader> <CardTitle>Messages et notifications</CardTitle> <CardDescription>Communications concernant votre commande</CardDescription> </CardHeader> <CardContent> <div className="space-y-4 max-h-64 overflow-y-auto"> {orderData.messages.map((message) => ( <div ={message.id} className="border rounded-lg p-4"> <div className="flex items-center justify-between mb-2"> <Badge className={messageTypes.find(t => t.value === message.type)?.color}> {messageTypes.find(t => t.value === message.type)?.label} </Badge> <span className="text-xs text-muted-foreground"> {formatDateTime(message.timestamp)} </span> </div> <p className="text-sm">{message.message}</p> {message.employeeName && ( <p className="text-xs text-muted-foreground mt-1"> Par: {message.employeeName} </p> )} </div> ))} </div> {/* Contact Form */} <div className="mt-4 pt-4 border-t"> <Label htmlFor="client-message">Envoyer un message</Label> <div className="flex gap-2 mt-2"> <Input id="client-message" value={newMessage} onChange={(e) => setNewMessage(e.target.value)} placeholder="Une question sur votre commande ?" /> <Button onClick={handleSendMessage} disabled={!newMessage.trim()} size="sm" > <Send className="h-4 w-4" /> </Button> </div> </div> </CardContent> </Card> </div> {/* Sidebar */} <div className="space-y-6"> {/* Order Details */} <Card> <CardHeader> <CardTitle>Détails de la commande</CardTitle> </CardHeader> <CardContent className="space-y-4"> <div className="flex items-center gap-3"> <User className="h-4 w-4 text-muted-foreground" /> <div> <p className="font-medium">{orderData.order.customerName}</p> <p className="text-sm text-muted-foreground">{orderData.order.customerPhone}</p> </div> </div> {orderData.order.deliveryAddress && ( <div className="flex items-center gap-3"> <MapPin className="h-4 w-4 text-muted-foreground" /> <p className="text-sm">{orderData.order.deliveryAddress}</p> </div> )} <div className="border-t pt-4"> <h4 className="font-medium mb-3">Articles commandés:</h4> <div className="space-y-2"> {orderData.order.items.map((item, index) => ( <div ={index} className="flex justify-between text-sm"> <span>{item.quantity}x {item.name}</span> <span className="font-medium">{item.price}€</span> </div> ))} </div> <div className="border-t mt-3 pt-3 flex justify-between font-semibold"> <span>Total</span> <span className="text-red-600">{orderData.order.total}€</span> </div> </div> {orderData.order.specialInstructions && ( <div className="bg-yellow-50 p-3 rounded-lg"> <p className="text-sm font-medium text-yellow-800">Instructions spéciales:</p> <p className="text-sm text-yellow-700">{orderData.order.specialInstructions}</p> </div> )} <div className="flex items-center gap-2 text-sm text-muted-foreground"> <Pizza className="h-4 w-4" /> <span>{orderData.order.deliveryMethod === 'delivery' ? 'Livraison' : 'À emporter'}</span> </div> </CardContent> </Card> {/* Contact */} <Card> <CardHeader> <CardTitle>Besoin d'aide ?</CardTitle> </CardHeader> <CardContent className="space-y-3"> <Button variant="outline" className="w-full justify-start"> <Phone className="h-4 w-4 mr-2" /> Appeler le restaurant </Button> <Button variant="outline" className="w-full justify-start"> <MessageSquare className="h-4 w-4 mr-2" /> Chat en direct </Button> </CardContent> </Card> </div> </div> </div> </div> );
}