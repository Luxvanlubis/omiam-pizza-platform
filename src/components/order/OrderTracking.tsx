"use client";

import { useState, useEffect } from 'react';
import { useAuth } from '@/components/auth-provider';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Separator } from '@/components/ui/separator';
import { Package, Truck, CheckCircle, Clock, MapPin, Phone, Mail, AlertCircle, RefreshCw, Bell, XCircle
} from 'lucide-react';
import { format } from 'date-fns';
import { fr } from 'date-fns/locale';
import { useWebSocket } from '@/hooks/useWebSocket';
import { useLocalizedFormat } from '@/hooks/useLocalizedFormat';

// Types pour le suivi de commande
interface OrderStatus { status: string; timestamp: Date; location?: string; message?: string; employee?: string;
}

interface OrderMessage { id: string; type: 'info' | 'warning' | 'success' | 'error'; message: string; timestamp: Date; employee?: string;
}

interface OrderTrackingData { orderId: string; currentStatus: OrderStatus; statusHistory: OrderStatus[]; messages: OrderMessage[]; estimatedDelivery?: Date; deliveryAddress?: string; customerInfo?: { name: string; phone?: string; email?: string; };
}

// Interface pour les props du composant
interface OrderTrackingProps { orderId: string; initialData?: OrderTrackingData | null;
}

// Étapes de commande
const ORDER_STEPS = [ { : 'PENDING', label: 'En attente', icon: Clock, color: 'bg-yellow-500' }, { : 'CONFIRMED', label: 'Confirmée', icon: CheckCircle, color: 'bg-blue-500' }, { : 'PREPARING', label: 'En préparation', icon: Package, color: 'bg-orange-500' }, { : 'COOKING', label: 'En cuisson', icon: Package, color: 'bg-red-500' }, { : 'READY', label: 'Prête', icon: CheckCircle, color: 'bg-green-500' }, { : 'OUT_FOR_DELIVERY', label: 'En livraison', icon: Truck, color: 'bg-purple-500' }, { : 'DELIVERED', label: 'Livrée', icon: CheckCircle, color: 'bg-green-600' }
];

// Fonction utilitaire pour obtenir l'index de l'étape actuelle
const getCurrentStepIndex = (status: string): number => { return ORDER_STEPS.findIndex(step => step. === status);
};

// Fonction utilitaire pour calculer le pourcentage de progression
const getProgressPercentage = (status: string): number => { if (status === 'CANCELLED') return 0; const currentIndex = getCurrentStepIndex(status); if (currentIndex === -1) return 0; return ((currentIndex + 1) / ORDER_STEPS.length) * 100;
};

// Fonction utilitaire pour obtenir la couleur du message
const getMessageColor = (type: string): string => { const colors: Record<string, string> = { 'info': 'bg-blue-50 border-blue-200 text-blue-800', 'warning': 'bg-yellow-50 border-yellow-200 text-yellow-800', 'success': 'bg-green-50 border-green-200 text-green-800', 'error': 'bg-red-50 border-red-200 text-red-800' }; return colors[type] || colors.info;
};

// Fonction utilitaire pour obtenir l'icône du message
const getMessageIcon = (type: string) => { const icons: Record<string, any> = { 'info': Bell, 'warning': AlertCircle, 'success': CheckCircle, 'error': XCircle }; const Icon = icons[type] || Bell; return <Icon className="h-4 w-4" />;
};

export default function OrderTracking({ orderId, initialData }: OrderTrackingProps) { const { user } = useAuth(); const [trackingData, setTrackingData] = useState<OrderTrackingData | null>(initialData || null); const [loading, setLoading] = useState(!initialData); const [error, setError] = useState<string | null>(null); const [lastUpdate, setLastUpdate] = useState<Date>(new Date()); // WebSocket pour les mises à jour en temps réel const { socket, isConnected } = useWebSocket(); // Charger les données de suivi const fetchTrackingData = async () => { try { setLoading(true); const response = await fetch(`/api/orders/${orderId}/tracking`); if (!response.ok) { throw new Error('Erreur lors du chargement des données de suivi'); } const data = await response.json(); setTrackingData(data); setError(null); } catch (err) { setError(err instanceof Error ? err.message : 'Une erreur est survenue'); } finally { setLoading(false); } }; // Effet pour charger les données initiales useEffect(() => { if (!initialData) { fetchTrackingData(); } }, [orderId, initialData]); // Effet pour les mises à jour WebSocket useEffect(() => { if (socket && isConnected) { // S'abonner aux mises à jour de cette commande socket.emit('subscribe-order', orderId); // Écouter les mises à jour de statut socket.on('order-status-update', (data: { orderId: string; status: OrderStatus }) => { if (data.orderId === orderId) { setTrackingData(prev => { if (!prev) return null; return { ...prev, currentStatus: data.status, statusHistory: [...prev.statusHistory, data.status] }; }); setLastUpdate(new Date()); } }); // Écouter les nouveaux messages socket.on('order-message', (data: { orderId: string; message: OrderMessage }) => { if (data.orderId === orderId) { setTrackingData(prev => { if (!prev) return null; return { ...prev, messages: [...prev.messages, data.message] }; }); setLastUpdate(new Date()); } }); // Écouter les mises à jour du temps de livraison estimé socket.on('delivery-time-update', (data: { orderId: string; estimatedDelivery: Date }) => { if (data.orderId === orderId) { setTrackingData(prev => { if (!prev) return null; return { ...prev, estimatedDelivery: data.estimatedDelivery }; }); setLastUpdate(new Date()); } }); // Nettoyage return () => { socket.off('order-status-update'); socket.off('order-message'); socket.off('delivery-time-update'); socket.emit('unsubscribe-order', orderId); }; } }, [socket, isConnected, orderId]); // Affichage du chargement if (loading) { return ( <Card> <CardContent className="p-6"> <div className="flex items-center justify-center"> <RefreshCw className="h-6 w-6 animate-spin mr-2" /> <span>Chargement des informations de suivi...</span> </div> </CardContent> </Card> ); } // Affichage des erreurs if (error) { return ( <Card> <CardContent className="p-6"> <Alert variant="destructive"> <AlertCircle className="h-4 w-4" /> <AlertDescription> {error} </AlertDescription> </Alert> <Button onClick={fetchTrackingData} className="mt-4" variant="outline" > <RefreshCw className="h-4 w-4 mr-2" /> Réessayer </Button> </CardContent> </Card> ); } // Vérifier si les données sont disponibles if (!trackingData) { return ( <Card> <CardContent className="p-6"> <Alert> <AlertCircle className="h-4 w-4" /> <AlertDescription> Aucune donnée de suivi disponible pour cette commande. </AlertDescription> </Alert> </CardContent> </Card> ); } const currentStepIndex = getCurrentStepIndex(trackingData.currentStatus.status); const progressPercentage = getProgressPercentage(trackingData.currentStatus.status); const isCancelled = trackingData.currentStatus.status === 'CANCELLED'; return ( <div className="space-y-6"> {/* En-tête avec statut actuel */} <Card> <CardHeader> <div className="flex items-center justify-between"> <div> <h2 className="text-2xl font-bold">Commande #{orderId}</h2> <p className="text-muted-foreground"> Dernière mise à jour: {format(lastUpdate, 'dd/MM/yyyy à HH:mm', { locale: fr })} </p> </div> <div className="text-right"> <Badge variant={isCancelled ? 'destructive' : 'default'} className="text-lg px-4 py-2" > {isCancelled ? 'Annulée' : ORDER_STEPS.find(step => step. === trackingData.currentStatus.status)?.label || trackingData.currentStatus.status} </Badge> {trackingData.estimatedDelivery && !isCancelled && ( <p className="text-sm text-muted-foreground mt-2"> Livraison estimée: {format(trackingData.estimatedDelivery, 'dd/MM/yyyy à HH:mm', { locale: fr })} </p> )} </div> </div> </CardHeader> <CardContent> {!isCancelled && ( <div className="space-y-4"> <div className="flex justify-between text-sm text-muted-foreground"> <span>Progression</span> <span>{Math.round(progressPercentage)}%</span> </div> <Progress value={progressPercentage} className="h-2" /> </div> )} </CardContent> </Card> {/* Historique des statuts */} <Card> <CardHeader> <h3 className="text-lg font-semibold">Historique de la commande</h3> </CardHeader> <CardContent> <div className="space-y-4"> {trackingData.statusHistory.map((status, index) => { const step = ORDER_STEPS.find(s => s. === status.status); const Icon = step?.icon || Package; const isActive = index === trackingData.statusHistory.length - 1; return ( <div ={index} className="flex items-start space-x-4"> <div className={`w-10 h-10 rounded-full flex items-center justify-center ${ isActive ? step?.color'bg-gray-500' : 'bg-gray-200' }`}> <Icon className={`h-5 w-5 ${ isActive ? 'text-white' : 'text-gray-500' }`} /> </div> <div className="flex-1 min-w-0"> <div className="flex items-center justify-between"> <p className={`font-medium ${ isActive ? 'text-foreground' : 'text-muted-foreground' }`}> {step?.label || status.status} </p> <p className="text-sm text-muted-foreground"> {format(status.timestamp, 'dd/MM/yyyy HH:mm', { locale: fr })} </p> </div> {status.message && ( <p className="text-sm text-muted-foreground mt-1"> {status.message} </p> )} {status.location && ( <div className="flex items-center mt-1 text-sm text-muted-foreground"> <MapPin className="h-3 w-3 mr-1" /> {status.location} </div> )} {status.employee && ( <p className="text-xs text-muted-foreground mt-1"> Par: {status.employee} </p> )} </div> </div> ); })} </div> </CardContent> </Card> {/* Messages et notifications */} {trackingData.messages.length > 0 && ( <Card> <CardHeader> <h3 className="text-lg font-semibold">Messages et notifications</h3> </CardHeader> <CardContent> <div className="space-y-3"> {trackingData.messages.map((message, index) => ( <div ={message.id || index} className={`p-3 rounded-lg border ${getMessageColor(message.type)}`} > <div className="flex items-start space-x-2"> {getMessageIcon(message.type)} <div className="flex-1"> <p className="text-sm font-medium">{message.message}</p> <div className="flex items-center justify-between mt-1"> <p className="text-xs opacity-75"> {format(message.timestamp, 'dd/MM/yyyy à HH:mm', { locale: fr })} </p> {message.employee && ( <p className="text-xs opacity-75"> Par: {message.employee} </p> )} </div> </div> </div> </div> ))} </div> </CardContent> </Card> )} {/* Informations de contact et livraison */} {(trackingData.customerInfo || trackingData.deliveryAddress) && ( <Card> <CardHeader> <h3 className="text-lg font-semibold">Informations de livraison</h3> </CardHeader> <CardContent className="space-y-4"> {trackingData.deliveryAddress && ( <div> <h4 className="font-medium mb-2 flex items-center"> <MapPin className="h-4 w-4 mr-2" /> Adresse de livraison </h4> <p className="text-muted-foreground">{trackingData.deliveryAddress}</p> </div> )} {trackingData.customerInfo && ( <div> <h4 className="font-medium mb-2">Contact client</h4> <div className="space-y-2"> <p className="text-muted-foreground">{trackingData.customerInfo.name}</p> {trackingData.customerInfo.phone && ( <div className="flex items-center text-muted-foreground"> <Phone className="h-4 w-4 mr-2" /> {trackingData.customerInfo.phone} </div> )} {trackingData.customerInfo.email && ( <div className="flex items-center text-muted-foreground"> <Mail className="h-4 w-4 mr-2" /> {trackingData.customerInfo.email} </div> )} </div> </div> )} </CardContent> </Card> )} {/* Bouton de rafraîchissement */} <div className="flex justify-center"> <Button onClick={fetchTrackingData} variant="outline" disabled={loading} > <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} /> Actualiser </Button> </div> </div> );
}