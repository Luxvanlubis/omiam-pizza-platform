// API Inventory Movements - Stock Movement History
import { NextRequest, NextResponse } from 'next/server';
import { inventoryService } from '@/lib/inventory-service';

// GET - Obtenir l'historique des mouvements de stock
export async function GET(request: NextRequest) {
  try { const { searchParams } = new URL(request.url); const itemId = searchParams.get('itemId'); const limit = parseInt(searchParams.get('limit')'50'); const offset = parseInt(searchParams.get('offset')'0'); const type = searchParams.get('type'); // 'in', 'out', 'adjustment' const startDate = searchParams.get('startDate'); const endDate = searchParams.get('endDate'); const employeeId = searchParams.get('employeeId'); const orderId = searchParams.get('orderId'); // Validation des paramètres if (limit > 1000) { return NextResponse.json({ success: false, error: 'Limit cannot exceed 1000 records' }, { status: 400 }); } if (type && !['in', 'out', 'adjustment'].includes(type)) { return NextResponse.json({ success: false, error: 'Invalid type. Must be: in, out, or adjustment' }, { status: 400 }); } let movements; let totalCount = 0; if (itemId) { // Obtenir les mouvements pour un article spécifique movements = await inventoryService.getStockMovements(itemId, limit); // Pour un article spécifique, on peut compter plus facilement const allMovements = await inventoryService.getStockMovements(itemId, 1000); totalCount = allMovements.length; } else { // Obtenir tous les mouvements (simulation avec données mock) // Pour le moment, on retourne les mouvements de tous les articles const allItems = await inventoryService.getAllItems(); movements = []; for (const item of allItems.slice(0, 3)) { // Limiter pour éviter trop de données const itemMovements = await inventoryService.getStockMovements(item.id, Math.ceil(limit / 3)); movements.push(...itemMovements); } // Trier par timestamp décroissant et limiter movements = movements .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()) .slice(offset, offset + limit); totalCount = movements.length; } // Filtrer par type si spécifié if (type) { movements = movements.filter(movement => movement.type === type); } // Filtrer par employé si spécifié if (employeeId) { movements = movements.filter(movement => movement.employeeId === employeeId); } // Filtrer par commande si spécifié if (orderId) { movements = movements.filter(movement => movement.orderId === orderId); } // Filtrer par dates si spécifiées if (startDate || endDate) { const start = startDate ? new Date(startDate) : new Date('1900-01-01'); const end = endDate ? new Date(endDate) : new Date(); movements = movements.filter(movement => { const movementDate = new Date(movement.timestamp); return movementDate >= start && movementDate <= end; }); } // Calculer les statistiques des mouvements const stats = { total: movements.length, byType: { in: movements.filter(m => m.type === 'in').length, out: movements.filter(m => m.type === 'out').length, adjustment: movements.filter(m => m.type === 'adjustment').length }, totalQuantityIn: movements .filter(m => m.type === 'in') .reduce((sum, m) => sum + m.quantity, 0), totalQuantityOut: movements .filter(m => m.type === 'out') .reduce((sum, m) => sum + m.quantity, 0), totalValue: movements .filter(m => m.cost && typeof m.cost === 'number') .reduce((sum, m) => sum + (m.cost! * m.quantity), 0) }; // Informations de pagination const pagination = { limit, offset, total: totalCount, hasMore: movements.length === limit, page: Math.floor(offset / limit) + 1, totalPages: Math.ceil(totalCount / limit) }; return NextResponse.json({ success: true, movements, stats, pagination, filters: { itemId: itemId'all', type: type'all', startDate: startDate || null, endDate: endDate || null, employeeId: employeeId'all', orderId: orderId'all' }, timestamp: new Date().toISOString() });   } catch (error) { console.error('Inventory movements GET error:', error instanceof Error ? error.message : String(error)); return NextResponse.json({ success: false, error: error instanceof Error ? error.message : 'Unknown error', timestamp: new Date().toISOString() }, { status: 500 }); }
}

// POST - Créer un mouvement de stock manuel (ajustement)
export async function POST(request: NextRequest) {
  try { const body = await request.json(); // Validation des données const { itemId, quantity, reason, employeeId, type = 'adjustment', cost, batchNumber } = body; if (!itemId || typeof itemId !== 'string') { return NextResponse.json({ success: false, error: 'Item ID is required' }, { status: 400 }); } if (typeof quantity !== 'number') { return NextResponse.json({ success: false, error: 'Valid quantity is required' }, { status: 400 }); } if (!reason || typeof reason !== 'string') { return NextResponse.json({ success: false, error: 'Reason is required' }, { status: 400 }); } if (!employeeId || typeof employeeId !== 'string') { return NextResponse.json({ success: false, error: 'Employee ID is required' }, { status: 400 }); } if (!['in', 'out', 'adjustment'].includes(type)) { return NextResponse.json({ success: false, error: 'Invalid type. Must be: in, out, or adjustment' }, { status: 400 }); } // Vérifier que l'article existe const item = await inventoryService.getItemById(itemId); if (!item) { return NextResponse.json({ success: false, error: 'Item not found' }, { status: 404 }); } // Créer le mouvement selon le type let success = false; let newQuantity = 0; switch (type) { case 'in': success = await inventoryService.addStock(itemId, Math.abs(quantity), cost, batchNumber); break; case 'out': success = await inventoryService.consumeStock(itemId, Math.abs(quantity)); break; case 'adjustment': // Pour les ajustements, on peut avoir des quantités positives ou négatives if (quantity > 0) { success = await inventoryService.addStock(itemId, quantity, cost, batchNumber); } else { success = await inventoryService.consumeStock(itemId, Math.abs(quantity)); } break; } if (!success) { return NextResponse.json({ success: false, error: 'Failed to create stock movement. Check stock availability.' }, { status: 400 }); } // Obtenir l'article mis à jour const updatedItem = await inventoryService.getItemById(itemId); newQuantity = updatedItem?.currentStock || 0; // Obtenir les mouvements récents pour confirmation const recentMovements = await inventoryService.getStockMovements(itemId, 5); return NextResponse.json({ success: true, message: `Stock movement created successfully`, movement: { itemId, quantity, type, reason, employeeId, cost, batchNumber, timestamp: new Date().toISOString() }, updatedItem: { id: itemId, name: updatedItem?.name, currentStock: newQuantity, previousStock: item.currentStock }, recentMovements, timestamp: new Date().toISOString() });   } catch (error) { console.error('Inventory movements POST error:', error instanceof Error ? error.message : String(error)); return NextResponse.json({ success: false, error: error instanceof Error ? error.message : 'Unknown error', timestamp: new Date().toISOString() }, { status: 500 }); }
}