import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';
import { headers } from 'next/headers';

// Initialiser Stripe
const stripe = new Stripe(process.env.STRIPE__!, { apiVersion: '2025-07-30.basil', typescript: true,
});

// Cl√© secr√®te du webhook pour la v√©rification de signature
const webhook = process.env.STRIPE_WEBHOOK_!;

export async function POST(request: NextRequest) { try { // V√©rifier que le webhook  est configur√© if (!webhook) { console.error('STRIPE_WEBHOOK_ non configur√©'); return NextResponse.json( { error: 'Configuration webhook manquante' }, { status: 500 } ); } // R√©cup√©rer le body brut de la requ√™te const body = await request.text(); // R√©cup√©rer la signature Stripe const headersList = await headers(); const signature = headersList.get('stripe-signature'); if (!signature) { console.error('Signature Stripe manquante'); return NextResponse.json( { error: 'Signature manquante' }, { status: 400 } ); } let event: Stripe.Event; try { // V√©rifier la signature du webhook (s√©curit√© PCI DSS) event = stripe.webhooks.constructEvent(body, signature, webhook); } catch (err: any) { console.error('Erreur de v√©rification signature webhook:', err.message); return NextResponse.json( { error: 'Signature invalide' }, { status: 400 } ); } // Traiter les diff√©rents types d'√©v√©nements switch (event.type) { case 'payment_intent.succeeded': await handlePaymentSucceeded(event.data.object as Stripe.PaymentIntent); break; case 'payment_intent.payment_failed': await handlePaymentFailed(event.data.object as Stripe.PaymentIntent); break; case 'payment_intent.canceled': await handlePaymentCanceled(event.data.object as Stripe.PaymentIntent); break; case 'payment_intent.requires_action': await handlePaymentRequiresAction(event.data.object as Stripe.PaymentIntent); break; case 'charge.dispute.created': await handleChargeDispute(event.data.object as Stripe.Dispute); break; default: console.log(`√âv√©nement non g√©r√©: ${event.type}`); } return NextResponse.json({ received: true }); } catch (error: any) { console.error('Erreur webhook Stripe:', error); return NextResponse.json( { error: 'Erreur interne du serveur' }, { status: 500 } ); }
}

// Gestionnaire pour paiement r√©ussi
async function handlePaymentSucceeded(paymentIntent: Stripe.PaymentIntent) { try { console.log(`‚úÖ Paiement r√©ussi: ${paymentIntent.id}`); // Extraire les m√©tadonn√©es de la commande const metadata = paymentIntent.metadata; const customerEmail = metadata.customer_email; const orderType = metadata.order_type; const totalAmount = parseFloat(metadata.total_amount'0'); // Log s√©curis√© console.log(`Commande confirm√©e - Email: ${customerEmail}, Type: ${orderType}, Montant: ${totalAmount}‚Ç¨`); // TODO: Int√©grer avec la base de donn√©es pour cr√©er la commande // TODO: Envoyer email de confirmation // TODO: Notifier la cuisine via WebSocket // Exemple de structure de commande √† sauvegarder const orderData = { paymentIntentId: paymentIntent.id, customerEmail, orderType, totalAmount, status: 'confirmed', paymentStatus: 'paid', createdAt: new Date(), metadata }; console.log('Donn√©es de commande √† sauvegarder:', orderData); } catch (error) { console.error('Erreur lors du traitement du paiement r√©ussi:', error); }
}

// Gestionnaire pour paiement √©chou√©
async function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) { try { console.log(`‚ùå Paiement √©chou√©: ${paymentIntent.id}`); const metadata = paymentIntent.metadata; const customerEmail = metadata.customer_email; // Log de l'√©chec console.log(`√âchec de paiement - Email: ${customerEmail}, Raison: ${paymentIntent.last_payment_error?.message'Inconnue'}`); // TODO: Notifier le client de l'√©chec // TODO: Proposer des alternatives de paiement } catch (error) { console.error('Erreur lors du traitement du paiement √©chou√©:', error); }
}

// Gestionnaire pour paiement annul√©
async function handlePaymentCanceled(paymentIntent: Stripe.PaymentIntent) { try { console.log(`üö´ Paiement annul√©: ${paymentIntent.id}`); const metadata = paymentIntent.metadata; const customerEmail = metadata.customer_email; console.log(`Paiement annul√© - Email: ${customerEmail}`); // TODO: Nettoyer les donn√©es temporaires // TODO: Lib√©rer les stocks r√©serv√©s } catch (error) { console.error('Erreur lors du traitement du paiement annul√©:', error); }
}

// Gestionnaire pour paiement n√©cessitant une action
async function handlePaymentRequiresAction(paymentIntent: Stripe.PaymentIntent) { try { console.log(`‚ö†Ô∏è Paiement n√©cessite une action: ${paymentIntent.id}`); const metadata = paymentIntent.metadata; const customerEmail = metadata.customer_email; console.log(`Action requise - Email: ${customerEmail}`); // TODO: Notifier le client qu'une action est requise // TODO: Envoyer instructions par email si n√©cessaire } catch (error) { console.error('Erreur lors du traitement de l\'action requise:', error); }
}

// Gestionnaire pour litige de paiement
async function handleChargeDispute(dispute: Stripe.Dispute) { try { console.log(`‚öñÔ∏è Litige cr√©√©: ${dispute.id}`); // Log du litige pour investigation console.log(`Litige - Montant: ${dispute.amount / 100}‚Ç¨, Raison: ${dispute.reason}`); // TODO: Alerter l'√©quipe de gestion // TODO: Pr√©parer la documentation pour la r√©ponse au litige } catch (error) { console.error('Erreur lors du traitement du litige:', error); }
}

// Seule m√©thode POST autoris√©e pour les webhooks
export async function GET() { return NextResponse.json( { error: 'M√©thode non autoris√©e' }, { status: 405 } );
}

export async function PUT() { return NextResponse.json( { error: 'M√©thode non autoris√©e' }, { status: 405 } );
}

export async function DELETE() { return NextResponse.json( { error: 'M√©thode non autoris√©e' }, { status: 405 } );
}