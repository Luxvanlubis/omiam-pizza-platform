
/**
 * Valide et sécurise un chemin de fichier
 * @param {string} userPath - Chemin fourni par l'utilisateur
 * @param {string} basePath - Chemin de base autorisé
 * @returns {string} - Chemin sécurisé
 */
function validateSecurePath(userPath, basePath = process.cwd()) { if (!userPath || typeof userPath !== 'string') { throw new Error('Chemin invalide'); } // Normaliser le chemin et vérifier qu'il reste dans le répertoire autorisé const normalizedPath = path.normalize(path.join(basePath, userPath)); const normalizedBase = path.normalize(basePath); if (!normalizedPath.startsWith(normalizedBase)) { throw new Error('Accès au chemin non autorisé'); } return normalizedPath;
}
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { supabaseIntegrationService } from '../../../lib/supabase-integration-service';
import { OrderNotificationMiddleware } from '../../../lib/order-notification-middleware';

// Interface pour la création de commande
interface CreateOrderRequest { items: Array<{ productId: string; quantity: number; customizations?: { sizeId?: string; doughTypeId?: string; cookingLevelId?: string; ingredientIds?: string[]; }; unitPrice: number; }>; deliveryType: 'PICKUP' | 'DELIVERY'; deliveryAddress?: { street: string; city: string; postalCode: string; additionalInfo?: string; }; customerNotes?: string; estimatedDelivery?: string;
}

// Créer une nouvelle commande
export async function POST(request: NextRequest) {
  try { const supabase = createRouteHandlerClient({ cookies }); const { data: { session }, error: authError } = await supabase.auth.getSession(); if (authError || !session?.user) { return NextResponse.json( { error: 'Authentification requise' }, { status: 401 } ); } const body: CreateOrderRequest = await request.json(); // Validation des données if (!body.items || !Array.isArray(body.items) || body.items.length === 0) { return NextResponse.json( { error: 'Au moins un article est requis' }, { status: 400 } ); } if (!body.deliveryType || !['PICKUP', 'DELIVERY'].includes(body.deliveryType)) { return NextResponse.json( { error: 'Type de livraison invalide' }, { status: 400 } ); } if (body.deliveryType === 'DELIVERY' && !body.deliveryAddress) { return NextResponse.json( { error: 'Adresse de livraison requise pour la livraison' }, { status: 400 } ); } // Calculer le montant total let totalAmount = 0; const orderItems: Array<{ productId: string; quantity: number; unitPrice: number; totalPrice: number; customizations: any; }> = []; for (const item of body.items) { // Vérifier que le produit existe const { data: product, error: productError } = await supabase .from('products') .select('*') .eq('id', item.productId) .single(); if (productError || !product) { return NextResponse.json( { error: `Produit ${item.productId} non trouvé` }, { status: 400 } ); } // Calculer le prix avec les personnalisations let itemPrice = product.price; if (item.customizations) { // Ajouter le prix de la taille if (item.customizations.sizeId) { const { data: size } = await supabase .from('pizza_sizes') .select('*') .eq('id', item.customizations.sizeId) .single(); if (size) { itemPrice = size.base_price; } } // Ajouter le prix de la pâte if (item.customizations.doughTypeId) { const { data: dough } = await supabase .from('dough_types') .select('*') .eq('id', item.customizations.doughTypeId) .single(); if (dough && dough.extra_price) { itemPrice += dough.extra_price; } } // Ajouter le prix de la cuisson if (item.customizations.cookingLevelId) { const { data: cooking } = await supabase .from('cooking_levels') .select('*') .eq('id', item.customizations.cookingLevelId) .single(); if (cooking && cooking.extra_price) { itemPrice += cooking.extra_price; } } // Ajouter le prix des ingrédients if (item.customizations.ingredientIds && item.customizations.ingredientIds.length > 0) { const { data: ingredients } = await supabase .from('ingredients') .select('*') .in('id', item.customizations.ingredientIds); if (ingredients) { for (const ingredient of ingredients) { itemPrice += ingredient.price_modifier; } } } } const itemTotal = itemPrice * item.quantity; totalAmount += itemTotal; orderItems.push({ productId: item.productId, quantity: item.quantity, unitPrice: itemPrice, totalPrice: itemTotal, customizations: item.customizations || {} }); } // Créer la commande const { data: order, error: orderError } = await supabase .from('orders') .insert({ user_id: session.user.id, status: 'PENDING', total_amount: totalAmount, delivery_address: body.deliveryAddress ? JSON.stringify(body.deliveryAddress) : null, phone: session.user.email'N/A', notes: body.customerNotes }) .select() .single(); if (orderError || !order) { throw new Error('Erreur lors de la création de la commande'); } // Créer les articles de la commande const orderItemsData = orderItems.map(item => ({ order_id: order.id, product_id: item.productId, quantity: item.quantity, price: item.totalPrice, customizations: item.customizations })); const { error: itemsError } = await supabase .from('order_items') .insert(orderItemsData); if (itemsError) { // Supprimer la commande si les articles n'ont pas pu être créés await supabase.from('orders').delete().eq('id', order.id); throw new Error('Erreur lors de la création des articles de commande'); } // Envoyer les notifications de création de commande try { await OrderNotificationMiddleware.handleOrderCreated({ orderId: order.id, userId: session.user.id, totalAmount, estimatedDelivery: new Date(Date.now() + (35 * 60 * 1000)), metadata: { orderNumber: `OM${Date.now().toString().slice(-8)}`, deliveryType: body.deliveryType, itemCount: body.items.length } }); } catch (notificationError) { console.error('Erreur lors de l\'envoi des notifications:', notificationError instanceof Error ? notificationError.message : String(notificationError)); // Ne pas faire échouer la création de commande } // Récupérer la commande complète pour la réponse const { data: completeOrder } = await supabase .from('orders') .select(` *, order_items ( *, products (*) ), profiles ( id, full_name, email ) `) .eq('id', order.id) .single(); return NextResponse.json({ success: true, order: completeOrder, message: 'Commande créée avec succès' }, { status: 201 });   } catch (error) { console.error('Erreur lors de la création de la commande:', error instanceof Error ? error.message : String(error)); return NextResponse.json( { error: 'Erreur interne du serveur' }, { status: 500 } ); }
}

// Récupérer les commandes de l'utilisateur
export async function GET(request: NextRequest) {
  try { const supabase = createRouteHandlerClient({ cookies }); const { data: { session }, error: authError } = await supabase.auth.getSession(); if (authError || !session?.user) { return NextResponse.json( { error: 'Authentification requise' }, { status: 401 } ); } const { searchParams } = new URL(request.url); const page = parseInt(searchParams.get('page')'1'); const limit = parseInt(searchParams.get('limit')'10'); const status = searchParams.get('status'); const offset = (page - 1) * limit; // Construire la requête let query = supabase .from('orders') .select(` *, order_items ( *, products (*) ) `, { count: 'exact' }) .eq('user_id', session.user.id) .order('created_at', { ascending: false }) .range(offset, offset + limit - 1); if (status) { query = query.eq('status', status); } const { data: orders, error: ordersError, count } = await query; if (ordersError) { throw new Error('Erreur lors de la récupération des commandes'); } return NextResponse.json({ orders: orders || [], pagination: { page, limit, total: count || 0, pages: Math.ceil((count || 0) / limit) } });   } catch (error) { console.error('Erreur lors de la récupération des commandes:', error instanceof Error ? error.message : String(error)); return NextResponse.json( { error: 'Erreur interne du serveur' }, { status: 500 } ); }
}