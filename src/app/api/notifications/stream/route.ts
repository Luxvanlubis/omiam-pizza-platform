import { NextRequest } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { supabaseIntegrationService } from '@/lib/supabase-integration-service';
import { addConnection, removeConnection, sendNotificationToUser, broadcastNotification, getActiveConnections, clearAllConnections } from '@/lib/notification-utils';

export async function GET(request: NextRequest) { const { searchParams } = new URL(request.url); const userId = searchParams.get('userId'); if (!userId) { return new Response('userId requis', { status: 400 }); } // Vérifier que l'utilisateur existe try { const supabase = supabaseIntegrationService.getSupabaseClient(); const { data: user, error: userError } = await supabase .from('users') .select('id') .eq('id', userId) .single(); if (userError || !user) { return new Response('Utilisateur non trouvé', { status: 404 }); } } catch (error) { console.error('Erreur lors de la vérification de l\'utilisateur:', error); return new Response('Erreur serveur', { status: 500 }); } // Créer le stream pour Server-Sent Events const stream = new ReadableStream({ start(controller) { // Stocker la connexion addConnection(userId, controller); // Envoyer un message de connexion const welcomeMessage = `data: ${JSON.stringify({ type: 'connected', message: 'Connexion établie', timestamp: new Date().toISOString() })}\n\n`; controller.enqueue(new TextEncoder().encode(welcomeMessage)); // Envoyer un ping toutes les 30 secondes pour maintenir la connexion const pingInterval = setInterval(() => { try { const pingMessage = `data: ${JSON.stringify({ type: 'ping', timestamp: new Date().toISOString() })}\n\n`; controller.enqueue(new TextEncoder().encode(pingMessage)); } catch (error) { console.error('Erreur lors du ping:', error); clearInterval(pingInterval); removeConnection(userId); } }, 30000); // Nettoyer lors de la fermeture request.signal.addEventListener('abort', () => { clearInterval(pingInterval); removeConnection(userId); try { controller.close(); } catch (error) { // Connexion déjà fermée } }); }, cancel() { // Nettoyer la connexion removeConnection(userId); } }); // Retourner la réponse SSE return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Headers': 'Cache-Control', }, });
}

// Les fonctions de notification sont disponibles via notification-utils