import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { stripeService } from '@/lib/stripe-service';

/**
 * GET /api/stripe/health
 * Endpoint de diagnostic pour vÃ©rifier la configuration Stripe
 */
export async function GET(request: NextRequest) { try { // VÃ©rifier l'authentification (optionnel selon vos besoins) const supabase = createRouteHandlerClient({ cookies }); const { data: { session }, error: authError } = await supabase.auth.getSession(); if (authError || !session?.user) { return NextResponse.json( { error: 'Non autorisÃ©' }, { status: 401 } ); } // Effectuer le health check const healthCheck = await stripeService.healthCheck(); // Informations sur la configuration const configInfo = { publishableConfigured: !!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_, Configured: !!process.env.STRIPE__, webhookConfigured: !!process.env.STRIPE_WEBHOOK_, publishableType: process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_?.startsWith('pk__') ?  : process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_?.startsWith('pk_live_') ? 'live' : 'invalid', Type: process.env.STRIPE__?.startsWith('sk__') ?  : process.env.STRIPE__?.startsWith('sk_live_') ? 'live' : 'invalid', isMockMode: stripeService.isMockMode(), environment: process.env.NODE_ENV, }; // VÃ©rifications de cohÃ©rence const warnings = []; if (configInfo.publishableType !== configInfo.Type && configInfo.publishableType !== 'invalid' && configInfo.Type !== 'invalid') { warnings.push('Les clÃ©s publique et secrÃ¨te ne correspondent pas au mÃªme environnement (/live)'); } if (configInfo.environment === 'production' && configInfo.publishableType === ) { warnings.push('ClÃ©s de  utilisÃ©es en production'); } if (configInfo.environment === 'development' && configInfo.publishableType === 'live') { warnings.push('ClÃ©s de production utilisÃ©es en dÃ©veloppement'); } if (!configInfo.webhookConfigured) { warnings.push( webhook non configurÃ© - les notifications ne fonctionneront pas'); } return NextResponse.json({ success: true, timestamp: new Date().toISOString(), healthCheck, configuration: configInfo, warnings, recommendations: [ configInfo.isMockMode ? 'Configurez vos clÃ©s Stripe pour activer les vrais paiements' : null, !configInfo.webhookConfigured ? 'Configurez le webhook  pour les notifications' : null, configInfo.environment === 'production' && configInfo.publishableType ===  ? 'Utilisez les clÃ©s de production en environnement de production' : null ].filter(Boolean) }); } catch (error) { console.error('Erreur lors du health check Stripe:', error); return NextResponse.json( { success: false, error: 'Erreur lors de la vÃ©rification de la configuration Stripe', details: error instanceof Error ? error.message : 'Erreur inconnue', timestamp: new Date().toISOString() }, { status: 500 } ); }
}

/**
 * POST /api/stripe/health
 *  des fonctionnalitÃ©s Stripe de base
 */
export async function POST(request: NextRequest) { try { const supabase = createRouteHandlerClient({ cookies }); const { data: { session }, error: authError } = await supabase.auth.getSession(); if (authError || !session?.user) { return NextResponse.json( { error: 'Non autorisÃ©' }, { status: 401 } ); } const body = await request.json(); const { Type = 'basic' } = body; const results: any = { timestamp: new Date().toISOString(), Type, s: {} }; try { //  1: CrÃ©ation d'un PaymentIntent console.log('ðŸ§ª : CrÃ©ation PaymentIntent...'); const paymentIntent = await stripeService.createPaymentIntent( 10.50, 'eur', { : 'true', source: 'health-check', timestamp: new Date().toISOString() } ); results.s.paymentIntent = { success: true, id: paymentIntent.id, amount: paymentIntent.amount, currency: paymentIntent.currency, status: paymentIntent.status }; } catch (error) { results.s.paymentIntent = { success: false, error: error instanceof Error ? error.message : 'Erreur inconnue' }; } try { //  2: CrÃ©ation d'un Customer console.log('ðŸ§ª : CrÃ©ation Customer...'); const customer = await stripeService.createCustomer( -health-check@example.com', Health Check User', { : 'true', source: 'health-check', timestamp: new Date().toISOString() } ); results.s.customer = { success: true, id: customer.id, email: customer.email, name: customer.name }; } catch (error) { results.s.customer = { success: false, error: error instanceof Error ? error.message : 'Erreur inconnue' }; } // RÃ©sumÃ© des s const successfuls = Object.values(results.s).filter((: any) => .success).length; const totals = Object.s(results.s).length; results.summary = { totals, successfuls, faileds: totals - successfuls, success: successfuls === totals }; return NextResponse.json({ success: true, ...results }); } catch (error) { console.error('Erreur lors des s Stripe:', error); return NextResponse.json( { success: false, error: 'Erreur lors des s Stripe', details: error instanceof Error ? error.message : 'Erreur inconnue', timestamp: new Date().toISOString() }, { status: 500 } ); }
}