
/**
 * Valide et sécurise un chemin de fichier
 * @param {string} userPath - Chemin fourni par l'utilisateur
 * @param {string} basePath - Chemin de base autorisé
 * @returns {string} - Chemin sécurisé
 */
function validateSecurePath(userPath, basePath = process.cwd()) { if (!userPath || typeof userPath !== 'string') { throw new Error('Chemin invalide'); } // Normaliser le chemin et vérifier qu'il reste dans le répertoire autorisé const normalizedPath = path.normalize(path.join(basePath, userPath)); const normalizedBase = path.normalize(basePath); if (!normalizedPath.startsWith(normalizedBase)) { throw new Error('Accès au chemin non autorisé'); } return normalizedPath;
}
// inventory-service.ts - Service de gestion automatisée des stocks
import { SupabaseIntegrationService, Queries } from './supabase-integration';
import { emailService } from './email-service';
import { createClient } from '@supabase/supabase-js';
import type { Database } from '../types/supabase';

// Types dérivés de la base de données
type DBInventoryItem = Database['public']['Tables']['inventory_items']['Row'];
type DBStockMovement = Database['public']['Tables']['inventory_movements']['Row'];

export interface InventoryItem { id: string; name: string; category: string; currentStock: number; minStock: number; maxStock: number; unit: string; cost: number; supplier?: string; lastRestock: string; status: 'good' | 'low' | 'critical' | 'out_of_stock'; autoReorder: boolean; reorderPoint: number; reorderQuantity: number; location?: string; expiryDate?: string; batchNumber?: string; createdAt?: string; updatedAt?: string; description?: string; sku?: string;
}

export interface StockMovement { id: string; itemId: string; type: 'in' | 'out' | 'adjustment' | 'waste' | 'transfer'; quantity: number; reason: string; employeeId?: string; orderId?: string; timestamp: string; cost?: number; notes?: string;
}

export interface StockAlert { id: string; itemId: string; type: 'low_stock' | 'critical_stock' | 'out_of_stock' | 'expiry_warning' | 'reorder_needed'; message: string; priority: 'low' | 'medium' | 'high' | 'critical'; acknowledged: boolean; createdAt: string; acknowledgedAt?: string; acknowledgedBy?: string;
}

class InventoryService { private integrationService = new SupabaseIntegrationService(); private supabase = createClient( process.env.NEXT_PUBLIC_SUPABASE_URL'', process.env.NEXT_PUBLIC_SUPABASE_ANON_'' ); private mockMode = true; private isInitialized = false; private mockInventory: InventoryItem[] = [ { id: '1', name: 'Farine de blé T55', category: 'Ingrédients Base', currentStock: 50, minStock: 20, maxStock: 100, unit: 'kg', cost: 1.2, supplier: 'Minoterie Locale', lastRestock: '2024-01-10T10:00:00Z', status: 'good', autoReorder: true, reorderPoint: 25, reorderQuantity: 50, location: 'Réserve A1', expiryDate: '2024-06-15' }, { id: '2', name: 'Mozzarella di Bufala', category: 'Fromages', currentStock: 15, minStock: 10, maxStock: 30, unit: 'kg', cost: 8.5, supplier: 'Fromagerie Italienne', lastRestock: '2024-01-12T14:30:00Z', status: 'good', autoReorder: true, reorderPoint: 12, reorderQuantity: 20, location: 'Frigo B2', expiryDate: '2024-01-25' }, { id: '3', name: 'Sauce tomate San Marzano', category: 'Sauces', currentStock: 8, minStock: 10, maxStock: 25, unit: 'L', cost: 3.2, supplier: 'Import Italien', lastRestock: '2024-01-08T09:15:00Z', status: 'low', autoReorder: true, reorderPoint: 10, reorderQuantity: 15, location: 'Réserve A3' }, { id: '4', name: 'Champignons de Paris', category: 'Légumes', currentStock: 3, minStock: 5, maxStock: 15, unit: 'kg', cost: 4.8, supplier: 'Maraîcher Local', lastRestock: '2024-01-09T16:45:00Z', status: 'critical', autoReorder: true, reorderPoint: 5, reorderQuantity: 10, location: 'Frigo B1', expiryDate: '2024-01-20' }, { id: '5', name: 'Coca-Cola 1.5L', category: 'Boissons', currentStock: 48, minStock: 24, maxStock: 100, unit: 'bouteilles', cost: 1.8, supplier: 'Distributeur Boissons', lastRestock: '2024-01-11T11:20:00Z', status: 'good', autoReorder: true, reorderPoint: 30, reorderQuantity: 50, location: 'Réserve C1' } ]; private mockMovements: StockMovement[] = []; private mockAlerts: StockAlert[] = []; // Méthode utilitaire pour calculer le statut du stock private calculaockStatus(currentStock: number, minStock: number): 'good' | 'low' | 'critical' | 'out_of_stock' { if (currentStock <= 0) return 'out_of_stock'; if (currentStock <= minStock * 0.5) return 'critical'; if (currentStock <= minStock) return 'low'; return 'good'; } constructor() { this.initializeService(); } private async initializeService() { if (this.isInitialized) return; // Vérifier la disponibilité de la base de données try { const isConnected = await this.integrationService.checkConnection(); if (isConnected) { this.mockMode = false; console.log('✅ Inventory Service: Mode base de données activé'); } else { this.mockMode = true; console.log('⚠️ Inventory Service: Mode mock activé - pas de connexion DB'); } } catch (error) { console.log('⚠️ Inventory Service: Mode mock activé', error); this.mockMode = true; } this.isInitialized = true; // Démarrer les vérifications automatiques this.startAutomaticChecks(); } private async createTablesIfNotExists() { if (!this.supabase) return; try { // Créer la table inventory_items await this.supabase.rpc('create_inventory_tables', {}); console.log('✅ Tables d\'inventaire créées ou vérifiées'); } catch (error) { console.log('⚠️ Erreur lors de la création des tables:', error instanceof Error ? error.message : String(error)); // Continuer en mode mock si les tables ne peuvent pas être créées throw error; } } // Obtenir tous les articles d'inventaire async getAllItems(): Promise<InventoryItem[]> { if (this.mockMode) { return this.mockInventory; } try { // Utiliser Queries pour récupérer les articles const items = await Queries.getInventoryItems(); if (items && items.length > 0) { // Transformer les données au format attendu return items.map((item: any) => ({ id: String(item.id), name: item.name, category: item.category, currentStock: item.current_stock, minStock: item.min_stock, maxStock: item.max_stock || 0, unit: item.unit, cost: item.cost || 0, supplier: item.supplier, lastRestock: item.last_restock, status: this.calculaockStatus(item.current_stock, item.min_stock), autoReorder: item.auto_reorder || false, reorderPoint: item.reorder_point || item.min_stock, reorderQuantity: item.reorder_quantity || 0, location: item.location, expiryDate: item.expiry_date, batchNumber: item.batch_number, createdAt: item.created_at, updatedAt: item.updated_at, description: item.description, sku: item.sku })); } // Fallback vers le mode mock return this.mockInventory; } catch (error) { console.error('Erreur lors de la récupération des articles:', error instanceof Error ? error.message : String(error)); return this.mockInventory; } } // Obtenir un article par ID async getItemById(id: string): Promise<InventoryItem | null> { if (this.mockMode) { return this.mockInventory.find(item => item.id === id) || null; } try { if (this.supabase) { const { data, error } = await this.supabase .from('inventory_items') .select('*') .eq('id', id) .single(); if (error) throw error; return data as unknown as InventoryItem | null; } // Fallback vers le mode mock si Supabase n'est pas disponible console.warn('Supabase non disponible, utilisation du mode mock'); return this.mockInventory.find(item => item.id === id) || null; } catch (error) { console.error('Erreur lors de la récupération de l\'article:', error instanceof Error ? error.message : String(error)); return this.mockInventory.find(item => item.id === id) || null; } } // Mettre à jour le stock d'un article async updaock(itemId: string, newQuantity: number, reason: string, employeeId?: string): Promise<boolean> { const item = await this.getItemById(itemId); if (!item) return false; const oldQuantity = item.currentStock; const movement: StockMovement = { id: `mov_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, itemId, type: newQuantity > oldQuantity ? 'in' : newQuantity < oldQuantity ? 'out' : 'adjustment', quantity: Math.abs(newQuantity - oldQuantity), reason, employeeId, timestamp: new Date().toISOString(), notes: `Stock mis à jour de ${oldQuantity} à ${newQuantity} ${item.unit}` }; if (this.mockMode) { const itemIndex = this.mockInventory.findIndex(i => i.id === itemId); if (itemIndex !== -1) { this.mockInventory[itemIndex].currentStock = newQuantity; this.mockInventory[itemIndex].status = this.calculaatus(newQuantity, item.minStock, item.reorderPoint); this.mockMovements.push(movement); // Vérifier les alertes await this.checkStockAlerts(this.mockInventory[itemIndex]); return true; } return false; } try { if (this.supabase) { const { error } = await this.supabase .from('inventory_items') .update({ current_stock: newQuantity, // Note: status field might need to be added to DB schema }) .eq('id', itemId); if (error) throw error; // Enregistrer le mouvement const { error: movementError } = await this.supabase.from('inventory_movements').insert({ id: movement.id, item_id: movement.itemId, type: movement.type, quantity: movement.quantity, reason: movement.reason, employeeId: movement.employeeId || null, orderId: movement.orderId || null, timestamp: movement.timestamp, cost: movement.cost || null, notes: movement.notes || null }); if (movementError) { console.warn('Erreur lors de l\'enregistrement du mouvement:', movementError.message); } // Vérifier les alertes const updatedItem = { ...item, currentStock: newQuantity }; await this.checkStockAlerts(updatedItem); return true; } // Fallback vers le mode mock si Supabase n'est pas disponible const mockItem = this.mockInventory.find(i => i.id === itemId); if (mockItem) { mockItem.currentStock = newQuantity; mockItem.status = this.calculaatus(newQuantity, mockItem.minStock, mockItem.reorderPoint); } return true; } catch (error) { console.error('Erreur lors de la mise à jour du stock:', error instanceof Error ? error.message : String(error)); return false; } } // Consommer du stock (pour les commandes) async consumeStock(itemId: string, quantity: number, orderId?: string): Promise<boolean> { const item = await this.getItemById(itemId); if (!item || item.currentStock < quantity) { console.warn(`Stock insuffisant pour ${item?.name}: demandé ${quantity}, disponible ${item?.currentStock}`); return false; } return await this.updaock( itemId, item.currentStock - quantity, `Consommation pour commande ${orderId'inconnue'}`, 'system' ); } // Ajouter du stock (réapprovisionnement) async addStock(itemId: string, quantity: number, cost?: number, batchNumber?: string): Promise<boolean> { const item = await this.getItemById(itemId); if (!item) return false; const success = await this.updaock( itemId, item.currentStock + quantity, `Réapprovisionnement: +${quantity} ${item.unit}`, 'system' ); if (success && this.mockMode) { const itemIndex = this.mockInventory.findIndex(i => i.id === itemId); if (itemIndex !== -1) { this.mockInventory[itemIndex].lastRestock = new Date().toISOString(); if (batchNumber) { this.mockInventory[itemIndex].batchNumber = batchNumber; } } } return success; } // Calculer le statut du stock private calculaatus(currentStock: number, minStock: number, reorderPoint: number): InventoryItem['status'] { if (currentStock <= 0) return 'out_of_stock'; if (currentStock <= minStock * 0.5) return 'critical'; if (currentStock <= reorderPoint) return 'low'; return 'good'; } // Vérifier les alertes de stock private async checkStockAlerts(item: InventoryItem): Promise<void> { const alerts: StockAlert[] = []; // Alerte stock critique if (item.status === 'critical') { alerts.push({ id: `alert_${Date.now()}_critical`, itemId: item.id, type: 'critical_stock', message: `Stock critique pour ${item.name}: ${item.currentStock} ${item.unit} restant(s)`, priority: 'critical', acknowledged: false, createdAt: new Date().toISOString() }); } // Alerte stock bas if (item.status === 'low') { alerts.push({ id: `alert_${Date.now()}_low`, itemId: item.id, type: 'low_stock', message: `Stock bas pour ${item.name}: ${item.currentStock} ${item.unit} restant(s)`, priority: 'high', acknowledged: false, createdAt: new Date().toISOString() }); } // Alerte rupture de stock if (item.status === 'out_of_stock') { alerts.push({ id: `alert_${Date.now()}_out`, itemId: item.id, type: 'out_of_stock', message: `Rupture de stock pour ${item.name}`, priority: 'critical', acknowledged: false, createdAt: new Date().toISOString() }); } // Alerte réapprovisionnement automatique if (item.autoReorder && item.currentStock <= item.reorderPoint) { alerts.push({ id: `alert_${Date.now()}_reorder`, itemId: item.id, type: 'reorder_needed', message: `Réapprovisionnement nécessaire pour ${item.name}: commander ${item.reorderQuantity} ${item.unit}`, priority: 'medium', acknowledged: false, createdAt: new Date().toISOString() }); } // Alerte expiration proche if (item.expiryDate) { const expiryDate = new Date(item.expiryDate); const now = new Date(); const daysUntilExpiry = Math.ceil((expiryDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)); if (daysUntilExpiry <= 3 && daysUntilExpiry > 0) { alerts.push({ id: `alert_${Date.now()}_expiry`, itemId: item.id, type: 'expiry_warning', message: `${item.name} expire dans ${daysUntilExpiry} jour(s)`, priority: 'high', acknowledged: false, createdAt: new Date().toISOString() }); } } // Enregistrer les alertes for (const alert of alerts) { await this.createAlert(alert); } // Envoyer des notifications email pour les alertes critiques const criticalAlerts = alerts.filter(a => a.priority === 'critical'); if (criticalAlerts.length > 0) { await this.sendStockAlertEmail(item, criticalAlerts); } } // Créer une alerte private async createAlert(alert: StockAlert): Promise<void> { if (this.mockMode) { // Éviter les doublons const exists = this.mockAlerts.some(a => a.itemId === alert.itemId && a.type === alert.type && !a.acknowledged ); if (!exists) { this.mockAlerts.push(alert); } return; } try { if (this.supabase) { const { error } = await this.supabase.from('inventory_alerts').insert({ id: alert.id, item_id: alert.itemId, type: alert.type, message: alert.message, // priority: alert.priority, // Field might not exist in DB is_acknowledged: alert.acknowledged, created_at: alert.createdAt, acknowledged_at: alert.acknowledgedAt || null, acknowledged_by: alert.acknowledgedBy || null }); if (error) { console.error('Erreur lors de la création de l\'alerte:', error.message); } } } catch (error) { console.error('Erreur lors de la création de l\'alerte:', error instanceof Error ? error.message : String(error)); } } // Envoyer un email d'alerte de stock private async sendStockAlertEmail(item: InventoryItem, alerts: StockAlert[]): Promise<void> { try { const alertMessages = alerts.map(a => a.message).join('\n'); await emailService.sendEmail({ to: 'manager@omiam.fr', // Email du gestionnaire subject: `🚨 Alerte Stock - ${item.name}`, html: ` <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;"> <h1 style="color: #e74c3c;">🚨 Alerte de Stock</h1> <p><strong>Article :</strong> ${item.name}</p> <p><strong>Stock actuel :</strong> ${item.currentStock} ${item.unit}</p> <p><strong>Emplacement :</strong> ${item.location'Non spécifié'}</p> <p><strong>Fournisseur :</strong> ${item.supplier'Non spécifié'}</p> <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;"> <h3>Alertes :</h3> <p>${alertMessages}</p> </div> <p><em>Système de gestion OMIAM</em></p> </div> `, text: `Alerte Stock - ${item.name}: ${item.currentStock} ${item.unit}. ${alertMessages}` }); } catch (error) { console.error('Erreur lors de l\'envoi de l\'email d\'alerte:', error instanceof Error ? error.message : String(error)); } } // Obtenir les alertes actives async getActiveAlerts(): Promise<StockAlert[]> { if (this.mockMode) { return this.mockAlerts.filter(a => !a.acknowledged); } try { if (this.supabase) { const { data, error } = await this.supabase .from('stock_alerts') .select('*') .eq('acknowledged', false) .order('createdAt', { ascending: false }); if (error) throw error; return (data as unknown as StockAlert[]) || []; } return []; } catch (error) { console.error('Erreur lors de la récupération des alertes:', error instanceof Error ? error.message : String(error)); return []; } } // Acquitter une alerte async acknowledgeAlert(alertId: string, employeeId: string): Promise<boolean> { if (this.mockMode) { const alertIndex = this.mockAlerts.findIndex(a => a.id === alertId); if (alertIndex !== -1) { this.mockAlerts[alertIndex].acknowledged = true; this.mockAlerts[alertIndex].acknowledgedAt = new Date().toISOString(); this.mockAlerts[alertIndex].acknowledgedBy = employeeId; return true; } return false; } try { if (this.supabase) { const { error } = await this.supabase .from('stock_alerts') .update({ acknowledged: true, acknowledgedAt: new Date().toISOString(), acknowledgedBy: employeeId }) .eq('id', alertId); return !error; } return false; } catch (error) { console.error('Erreur lors de l\'acquittement de l\'alerte:', error instanceof Error ? error.message : String(error)); return false; } } // Obtenir l'historique des mouvements async getStockMovements(itemId?: string, limit: number = 50): Promise<StockMovement[]> { if (this.mockMode) { let movements = this.mockMovements; if (itemId) { movements = movements.filter(m => m.itemId === itemId); } return movements.slice(-limit).reverse(); } try { const supabaseService = new SupabaseIntegrationService(); const supabase = supabaseService.getClient(); if (supabase) { let query = supabase .from('inventory_movements') .select('*') .order('created_at', { ascending: false }) .limit(limit); if (itemId) { query = query.eq('item_id', itemId); } const { data, error } = await query; if (error) throw error; return (data as unknown as StockMovement[]) || []; } return []; } catch (error) { console.error('Erreur lors de la récupération des mouvements:', error instanceof Error ? error.message : String(error)); return []; } } // Démarrer les vérifications automatiques private startAutomaticChecks(): void { // Vérification toutes les heures setInterval(async () => { const items = await this.getAllItems(); for (const item of items) { await this.checkStockAlerts(item); } }, 60 * 60 * 1000); // 1 heure console.log('✅ Vérifications automatiques des stocks démarrées'); } // Obtenir les statistiques d'inventaire async getInventoryStats(): Promise<{ totalItems: number; lowStockItems: number; criticalStockItems: number; outOfStockItems: number; totalValue: number; activeAlerts: number; }> { const items = await this.getAllItems(); const alerts = await this.getActiveAlerts(); return { totalItems: items.length, lowStockItems: items.filter(i => i.status === 'low').length, criticalStockItems: items.filter(i => i.status === 'critical').length, outOfStockItems: items.filter(i => i.status === 'out_of_stock').length, totalValue: items.reduce((sum, item) => sum + (item.currentStock * item.cost), 0), activeAlerts: alerts.length }; } // Vérification de santé du service async healthCheck(): Promise<{ status: 'healthy' | 'error'; mode: 'database' | 'mock'; itemsCount: number; activeAlerts: number; lastCheck: string; }> { try { const items = await this.getAllItems(); const alerts = await this.getActiveAlerts(); return { status: 'healthy', mode: this.mockMode ? 'mock' : 'database', itemsCount: items.length, activeAlerts: alerts.length, lastCheck: new Date().toISOString() }; } catch (error) { return { status: 'error', mode: this.mockMode ? 'mock' : 'database', itemsCount: 0, activeAlerts: 0, lastCheck: new Date().toISOString() }; } }
}

// Instance singleton
export const inventoryService = new InventoryService();
export default inventoryService;