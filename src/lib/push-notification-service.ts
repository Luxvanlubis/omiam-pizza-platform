
/**
 * Valide et sécurise un chemin de fichier
 * @param {string} userPath - Chemin fourni par l'utilisateur
 * @param {string} basePath - Chemin de base autorisé
 * @returns {string} - Chemin sécurisé
 */
function validateSecurePath(userPath, basePath = process.cwd()) { if (!userPath || typeof userPath !== 'string') { throw new Error('Chemin invalide'); } // Normaliser le chemin et vérifier qu'il reste dans le répertoire autorisé const normalizedPath = path.normalize(path.join(basePath, userPath)); const normalizedBase = path.normalize(basePath); if (!normalizedPath.startsWith(normalizedBase)) { throw new Error('Accès au chemin non autorisé'); } return normalizedPath;
}
import * as webpush from 'web-push';
import { SupabaseIntegrationService } from './supabase-integration';
import type { Database } from '../types/supabase';

// Types dérivés de la base de données
type DBNotification = Database['public']['Tables']['notifications']['Row'];
type DBNotificationPreference = Database['public']['Tables']['notification_preferences']['Row'];

// Interface étendue pour PushSubscription avec les clés
interface ExtendedPushSubscription extends PushSubscription { s: { p256dh: string; auth: string; };
}

// Configuration Web Push
if (process.env.VAPID_PUBLIC_ && process.env.VAPID_PRIVATE_) { webpush.setVapidDetails( 'mailto:contact@omiam.fr', process.env.VAPID_PUBLIC_, process.env.VAPID_PRIVATE_ );
}

export interface PushNotificationPayload { title: string; message: string; icon?: string; badge?: string; image?: string; url?: string; tag?: string; data?: any;
}

export interface NotificationData { userId: string; type: 'ORDER_CONFIRMED' | 'ORDER_PREPARING' | 'ORDER_READY' | 'ORDER_DELIVERED' | 'ORDER_CANCELLED' | 'PROMOTION' | 'NEW_PRODUCT' | 'LOYALTY_REWARD' | 'SYSTEM_MESSAGE' | 'PAYMENT_SUCCESS' | 'PAYMENT_FAILED'; title: string; message: string; orderId?: string; data?: any;
}

export class PushNotificationService { private integrationService = supabaseIntegrationService; /** * Enregistrer une nouvelle souscription push */ async subscribeToPush(userId: string, subscription: ExtendedPushSubscription, userAgent?: string) { try { // Utiliser le service d'intégration pour gérer les souscriptions push const subscriptionData = { user_id: userId, endpoint: subscription.endpoint, p256dh: subscription.s.p256dh, auth: subscription.s.auth, user_agent: userAgent, is_active: true }; // Vérifier si une souscription existe déjà const existingSubscriptions = await this.integrationService.executeQuery( 'push_subscriptions', { filters: { user_id: userId, endpoint: subscription.endpoint } } ); if (existingSubscriptions && existingSubscriptions.length > 0) { // Mettre à jour la souscription existante return await this.integrationService.executeMutation( 'push_subscriptions', 'update', { id: existingSubscriptions[0].id, ...subscriptionData, updated_at: new Date().toISOString() } ); } else { // Créer une nouvelle souscription return await this.integrationService.executeMutation( 'push_subscriptions', 'insert', subscriptionData ); } } catch (error) { console.error('Error subscribing to push notifications:', error instanceof Error ? error.message : String(error)); throw error; } } /** * Désabonner d'une souscription push */ async unsubscribeFromPush(userId: string, endpoint: string) { try { // Récupérer les souscriptions à désactiver const subscriptions = await this.integrationService.executeQuery( 'push_subscriptions', { filters: { user_id: userId, endpoint: endpoint } } ); if (subscriptions && subscriptions.length > 0) { // Désactiver toutes les souscriptions correspondantes const updatePromises = subscriptions.map(sub => this.integrationService.executeMutation( 'push_subscriptions', 'update', { id: sub.id, is_active: false, updated_at: new Date().toISOString() } ) ); return await Promise.all(updatePromises); } return []; } catch (error) { console.error('Error unsubscribing from push notifications:', error instanceof Error ? error.message : String(error)); throw error; } } /** * Envoyer une notification push à un utilisateur spécifique */ async sendPushNotification(notificationData: NotificationData) { try { const { userId, type, title, message, orderId, data } = notificationData; // Vérifier les préférences de notification de l'utilisateur const preferencesResult = await this.integrationService.executeQuery( 'notification_preferences', { filters: { user_id: userId } } ); const preferences = preferencesResult && preferencesResult.length > 0 ? preferencesResult[0] : null; if (!preferences?.push_notifications) { console.log(`Push notifications disabled for user ${userId}`); return; } // Vérifier le type de notification selon les préférences const shouldSend = this.shouldSendNotification(type, preferences); if (!shouldSend) { console.log(`Notification type ${type} disabled for user ${userId}`); return; } // Récupérer toutes les souscriptions actives de l'utilisateur const subscriptions = await this.integrationService.executeQuery( 'push_subscriptions', { filters: { user_id: userId, is_active: true } } ); if (!subscriptions || subscriptions.length === 0) { console.log(`No active push subscriptions for user ${userId}`); return; } // Créer la notification dans la base de données const notificationData = { user_id: userId, type, title, message, order_id: orderId, data: data ? JSON.stringify(data) : null, is_push: true, created_at: new Date().toISOString() }; const notification = await this.integrationService.executeMutation( 'notifications', 'insert', notificationData ); // Préparer le payload de la notification push const payload: PushNotificationPayload = { title, message, icon: '/favicon.ico', badge: '/favicon.ico', url: this.getNotificationUrl(type, orderId), tag: `notification-${notification.id}`, data: { notificationId: notification.id, type, orderId, ...data } }; // Envoyer la notification à toutes les souscriptions const sendPromises = subscriptions.map(async (subscription) => { try { const pushSubscription = { endpoint: subscription.endpoint, s: { p256dh: subscription.p256dh, auth: subscription.auth } }; await webpush.sendNotification( pushSubscription, JSON.stringify(payload), { TTL: 24 * 60 * 60, // 24 heures urgency: this.getUrgency(type) } ); console.log(`Push notification sent successfully to ${subscription.endpoint}`); } catch (error: any) { console.error(`Failed to send push notification to ${subscription.endpoint}:`, error instanceof Error ? error.message : String(error)); // Si la souscription est invalide, la désactiver if (error.statusCode === 410 || error.statusCode === 404) { const supabase = SupabaseIntegrationService.getSupabaseClient(); await supabase .from('push_subscriptions') .update({ is_active: false }) .eq('id', subscription.id); } } }); await Promise.allSettled(sendPromises); return notification; } catch (error) { console.error('Error sending push notification:', error instanceof Error ? error.message : String(error)); throw error; } } /** * Envoyer une notification push à plusieurs utilisateurs */ async sendBulkPushNotifications(userIds: string[], notificationData: Omit<NotificationData, 'userId'>) { const sendPromises = userIds.map(userId => this.sendPushNotification({ ...notificationData, userId }) ); return await Promise.allSettled(sendPromises); } /** * Envoyer une notification de mise à jour de commande */ async sendOrderStatusNotification(orderId: string, status: string, estimatedTime?: number) { try { const orderResult = await this.integrationService.executeQuery( 'orders', { filters: { id: orderId }, joins: ['users'] } ); const order = orderResult && orderResult.length > 0 ? orderResult[0] : null; if (!order) { throw new Error(`Order ${orderId} not found`); } const statusMessages = { CONFIRMED: 'Votre commande a été confirmée !', PREPARING: 'Votre commande est en préparation', READY: 'Votre commande est prête !', DELIVERED: 'Votre commande a été livrée', CANCELLED: 'Votre commande a été annulée' }; const message = statusMessages[status as of typeof statusMessages] || `Statut de commande: ${status}`; const title = `Commande #${orderId.slice(-6)}`; return await this.sendPushNotification({ userId: order.userId, type: `ORDER_${status}` as any, title, message: estimatedTime ? `${message} (Temps estimé: ${estimatedTime} min)` : message, orderId, data: { status, estimatedTime } }); } catch (error) { console.error('Error sending order status notification:', error instanceof Error ? error.message : String(error)); throw error; } } /** * Déterminer si une notification doit être envoyée selon les préférences */ private shouldSendNotification(type: string, preferences: any): boolean { switch (type) { case 'ORDER_CONFIRMED': case 'ORDER_PREPARING': case 'ORDER_READY': case 'ORDER_DELIVERED': case 'ORDER_CANCELLED': return preferences.order_status_updates; case 'PROMOTION': return preferences.promotions; case 'NEW_PRODUCT': return preferences.new_products; case 'LOYALTY_REWARD': return preferences.loyalty_rewards; case 'SYSTEM_MESSAGE': return preferences.system_messages; default: return true; } } /** * Obtenir l'URL de destination pour une notification */ private getNotificationUrl(type: string, orderId?: string): string { switch (type) { case 'ORDER_CONFIRMED': case 'ORDER_PREPARING': case 'ORDER_READY': case 'ORDER_DELIVERED': case 'ORDER_CANCELLED': return orderId ? `/suivi-commande?id=${orderId}` : '/suivi-commande'; case 'PROMOTION': return '/menu'; case 'NEW_PRODUCT': return '/menu'; case 'LOYALTY_REWARD': return '/fidelite'; default: return '/'; } } /** * Déterminer l'urgence de la notification */ private getUrgency(type: string): 'very-low' | 'low' | 'normal' | 'high' { switch (type) { case 'ORDER_READY': case 'ORDER_DELIVERED': case 'PAYMENT_FAILED': return 'high'; case 'ORDER_CONFIRMED': case 'ORDER_PREPARING': return 'normal'; case 'PROMOTION': case 'NEW_PRODUCT': return 'low'; default: return 'normal'; } } /** * Obtenir les notifications d'un utilisateur */ async getUserNotifications(userId: string, limit = 50, offset = 0) { return await this.integrationService.executeQuery( 'notifications', { filters: { user_id: userId }, orderBy: { created_at: 'desc' }, limit, offset, joins: ['orders'] } ); } /** * Marquer une notification comme lue */ async markNotificationAsRead(notificationId: string, userId: string) { // Récupérer la notification à mettre à jour const notifications = await this.integrationService.executeQuery( 'notifications', { filters: { id: notificationId, user_id: userId } } ); if (notifications && notifications.length > 0) { return await this.integrationService.executeMutation( 'notifications', 'update', { id: notificationId, is_read: true, updated_at: new Date().toISOString() } ); } return null; } /** * Marquer toutes les notifications comme lues */ async markAllNotificationsAsRead(userId: string) { // Récupérer toutes les notifications non lues const unreadNotifications = await this.integrationService.executeQuery( 'notifications', { filters: { user_id: userId, is_read: false } } ); if (unreadNotifications && unreadNotifications.length > 0) { const updatePromises = unreadNotifications.map(notification => this.integrationService.executeMutation( 'notifications', 'update', { id: notification.id, is_read: true, updated_at: new Date().toISOString() } ) ); return await Promise.all(updatePromises); } return []; } /** * Obtenir ou créer les préférences de notification d'un utilisateur */ async getUserNotificationPreferences(userId: string) { const preferencesResult = await this.integrationService.executeQuery( 'notification_preferences', { filters: { user_id: userId } } ); let preferences = preferencesResult && preferencesResult.length > 0 ? preferencesResult[0] : null; if (!preferences) { preferences = await this.integrationService.executeMutation( 'notification_preferences', 'insert', { user_id: userId, push_notifications: true, order_status_updates: true, promotions: true, new_products: false, loyalty_rewards: true, system_messages: true, created_at: new Date().toISOString() } ); } return preferences; } /** * Mettre à jour les préférences de notification d'un utilisateur */ async updateNotificationPreferences(userId: string, preferences: Partial<{ order_status_updates: boolean; promotions: boolean; new_products: boolean; loyalty_rewards: boolean; system_messages: boolean; email_notifications: boolean; push_notifications: boolean; sms_notifications: boolean; }>) { // Vérifier si les préférences existent déjà const existingPreferences = await this.integrationService.executeQuery( 'notification_preferences', { filters: { user_id: userId } } ); const preferencesData = { user_id: userId, ...preferences, updated_at: new Date().toISOString() }; if (existingPreferences && existingPreferences.length > 0) { // Mettre à jour les préférences existantes return await this.integrationService.executeMutation( 'notification_preferences', 'update', { id: existingPreferences[0].id, ...preferencesData } ); } else { // Créer de nouvelles préférences return await this.integrationService.executeMutation( 'notification_preferences', 'insert', { ...preferencesData, created_at: new Date().toISOString() } ); } }
}

export const pushNotificationService = new PushNotificationService();
export default pushNotificationService;