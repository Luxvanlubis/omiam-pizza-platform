import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { supabaseIntegrationService } from '@/lib/supabase/supabase-integration-service';

export interface AuditLogEntry { id?: string; userId?: string; userEmail?: string; action: AuditAction; resource: string; resourceId?: string; details?: Record<string, any>; ipAddress?: string; userAgent?: string; timestamp: Date; legalBasis?: string; dataCategories?: string[];
}

export enum AuditAction { // Actions sur les données personnelles DATA_ACCESS = 'DATA_ACCESS', DATA_CREATE = 'DATA_CREATE', DATA_UPDATE = 'DATA_UPDATE', DATA_DELETE = 'DATA_DELETE', DATA_EXPORT = 'DATA_EXPORT', // Actions RGPD spécifiques GDPR_REQUEST_SUBMITTED = 'GDPR_REQUEST_SUBMITTED', GDPR_REQUEST_PROCESSED = 'GDPR_REQUEST_PROCESSED', GDPR_DATA_EXPORTED = 'GDPR_DATA_EXPORTED', GDPR_DATA_DELETED = 'GDPR_DATA_DELETED', GDPR_CONSENT_GIVEN = 'GDPR_CONSENT_GIVEN', GDPR_CONSENT_WITHDRAWN = 'GDPR_CONSENT_WITHDRAWN', // Actions d'authentification USER_LOGIN = 'USER_LOGIN', USER_LOGOUT = 'USER_LOGOUT', USER_REGISTER = 'USER_REGISTER', // Actions istratives _ACCESS = _ACCESS', _DATA_VIEW = _DATA_VIEW', _DATA_MODIFY = _DATA_MODIFY', // Actions de sécurité SECURITY_BREACH_DETECTED = 'SECURITY_BREACH_DETECTED', UNAUTHORIZED_ACCESS_ATTEMPT = 'UNAUTHORIZED_ACCESS_ATTEMPT', // Actions de rétention DATA_RETENTION_APPLIED = 'DATA_RETENTION_APPLIED', DATA_ANONYMIZED = 'DATA_ANONYMIZED'
}

export class GDPRAuditLogger { /** * Enregistre une action dans les logs d'audit RGPD */ static async log(entry: Omit<AuditLogEntry, 'id' | 'timestamp'>) { try { const auditEntry: AuditLogEntry = { ...entry, timestamp: new Date() }; // En production, ceci serait sauvegardé en base de données // Pour la démo, on utilise console.log avec un format structuré console.log('[GDPR_AUDIT]', JSON.stringify({ timestamp: auditEntry.timestamp.toISOString(), action: auditEntry.action, userId: auditEntry.userId, userEmail: auditEntry.userEmail, resource: auditEntry.resource, resourceId: auditEntry.resourceId, ipAddress: auditEntry.ipAddress, userAgent: auditEntry.userAgent, legalBasis: auditEntry.legalBasis, dataCategories: auditEntry.dataCategories, details: auditEntry.details }, null, 2)); // Sauvegarde en base de données Supabase try { const supabase = supabaseIntegrationService.getSupabaseClient(); await supabase.from('audit_logs').insert({ user_id: auditEntry.userId, user_email: auditEntry.userEmail, action: auditEntry.action, resource: auditEntry.resource, resource_id: auditEntry.resourceId, details: auditEntry.details, ip_address: auditEntry.ipAddress, user_agent: auditEntry.userAgent, legal_basis: auditEntry.legalBasis, data_categories: auditEntry.dataCategories, timestamp: auditEntry.timestamp.toISOString() }); } catch (dbError) { console.error('[GDPR_AUDIT_DB_ERROR]', dbError instanceof Error ? dbError.message : String(dbError)); // Continue avec le log console même si la DB échoue } return auditEntry; } catch (error) { console.error('[GDPR_AUDIT_ERROR]', error instanceof Error ? error.message : String(error)); // En cas d'erreur, on ne doit pas bloquer l'application // mais on doit alerter les istrateurs } } /** * Log spécifique pour l'accès aux données personnelles */ static async logDataAccess({ userId, userEmail, resource, resourceId, dataCategories, ipAddress, userAgent, legalBasis = 'legitimate_interest' }: { userId?: string; userEmail?: string; resource: string; resourceId?: string; dataCategories: string[]; ipAddress?: string; userAgent?: string; legalBasis?: string; }) { return this.log({ userId, userEmail, action: AuditAction.DATA_ACCESS, resource, resourceId, dataCategories, ipAddress, userAgent, legalBasis, details: { accessType: 'read', dataTypes: dataCategories } }); } /** * Log spécifique pour les modifications de données personnelles */ static async logDataModification({ userId, userEmail, resource, resourceId, changes, dataCategories, ipAddress, userAgent, legalBasis = 'contract' }: { userId?: string; userEmail?: string; resource: string; resourceId?: string; changes: Record<string, { old: any; new: any }>; dataCategories: string[]; ipAddress?: string; userAgent?: string; legalBasis?: string; }) { return this.log({ userId, userEmail, action: AuditAction.DATA_UPDATE, resource, resourceId, dataCategories, ipAddress, userAgent, legalBasis, details: { changes, modifiedFields: Object.s(changes) } }); } /** * Log spécifique pour les demandes RGPD */ static async logGDPRRequest({ userId, userEmail, requestType, requestId, status, ipAddress, userAgent }: { userId?: string; userEmail: string; requestType: string; requestId: string; status: 'submitted' | 'processing' | 'completed' | 'rejected'; ipAddress?: string; userAgent?: string; }) { const action = status === 'submitted' ? AuditAction.GDPR_REQUEST_SUBMITTED : AuditAction.GDPR_REQUEST_PROCESSED; return this.log({ userId, userEmail, action, resource: 'gdpr_request', resourceId: requestId, ipAddress, userAgent, legalBasis: 'legal_obligation', dataCategories: ['personal_data'], details: { requestType, status, requestId } }); } /** * Log spécifique pour les consentements cookies */ static async logCookieConsent({ userId, userEmail, consentGiven, cookieCategories, ipAddress, userAgent }: { userId?: string; userEmail?: string; consentGiven: boolean; cookieCategories: string[]; ipAddress?: string; userAgent?: string; }) { const action = consentGiven ? AuditAction.GDPR_CONSENT_GIVEN : AuditAction.GDPR_CONSENT_WITHDRAWN; return this.log({ userId, userEmail, action, resource: 'cookie_consent', ipAddress, userAgent, legalBasis: 'consent', dataCategories: ['tracking_data'], details: { consentGiven, cookieCategories, consentTimestamp: new Date().toISOString() } }); } /** * Récupère les logs d'audit pour un utilisateur spécifique */ static async getUserAuditLogs({ userId, userEmail, startDate, endDate, actions }: { userId?: string; userEmail?: string; startDate?: Date; endDate?: Date; actions?: AuditAction[]; }) { try { const supabase = supabaseIntegrationService.getSupabaseClient(); let query = supabase .from('audit_logs') .select('*') .order('timestamp', { ascending: false }); // Filtrage par utilisateur if (userId || userEmail) { query = query.or(`user_id.eq.${userId},user_email.eq.${userEmail}`); } // Filtrage par dates if (startDate) { query = query.gte('timestamp', startDate.toISOString()); } if (endDate) { query = query.lte('timestamp', endDate.toISOString()); } // Filtrage par actions if (actions && actions.length > 0) { query = query.in('action', actions); } const { data, error } = await query; if (error) { console.error('[GDPR_AUDIT_QUERY_ERROR]', error.message); return []; } return data || []; } catch (error) { console.error('[GDPR_AUDIT_LOGS_ERROR]', error instanceof Error ? error.message : String(error)); return []; } } /** * Génère un rapport d'audit pour les autorités de contrôle */ static async generateComplianceReport({ startDate, endDate, includePersonalData = false }: { startDate: Date; endDate: Date; includePersonalData?: boolean; }) { // Dans un vrai projet, ceci générerait un rapport complet const report = { reportId: `AUDIT-${Date.now()}`, generatedAt: new Date().toISOString(), period: { start: startDate.toISOString(), end: endDate.toISOString() }, summary: { totalActions: 0, dataAccessCount: 0, gdprRequestsCount: 0, securityIncidents: 0 }, details: includePersonalData ? [] : 'Personal data excluded for privacy' }; console.log('[GDPR_COMPLIANCE_REPORT]', JSON.stringify(report, null, 2)); return report; }
}

/**
 * Middleware pour l'audit automatique des requêtes API
 */
export function createAuditMiddleware() { return async (req: any, res: any, next: any) => { const startTime = Date.now(); // Capture des informations de la requête const auditInfo = { method: req.method, url: req.url, ipAddress: req.ip || req.connection.remoteAddress, userAgent: req.get('User-Agent'), userId: req.user?.id, userEmail: req.user?.email }; // Log de l'accès API si c'est une route sensible if (req.url.includes('/api/user') || req.url.includes('/api/orders')) { await GDPRAuditLogger.log({ userId: auditInfo.userId, userEmail: auditInfo.userEmail, action: AuditAction.DATA_ACCESS, resource: `api_${req.url.split('/')[2]}`, ipAddress: auditInfo.ipAddress, userAgent: auditInfo.userAgent, legalBasis: 'legitimate_interest', details: { method: auditInfo.method, endpoint: auditInfo.url, duration: Date.now() - startTime } }); } next(); };
}

export default GDPRAuditLogger;