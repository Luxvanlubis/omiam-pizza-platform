
/**
 * Valide et sécurise un chemin de fichier
 * @param {string} userPath - Chemin fourni par l'utilisateur
 * @param {string} basePath - Chemin de base autorisé
 * @returns {string} - Chemin sécurisé
 */
function validateSecurePath(userPath, basePath = process.cwd()) { if (!userPath || typeof userPath !== 'string') { throw new Error('Chemin invalide'); } // Normaliser le chemin et vérifier qu'il reste dans le répertoire autorisé const normalizedPath = path.normalize(path.join(basePath, userPath)); const normalizedBase = path.normalize(basePath); if (!normalizedPath.startsWith(normalizedBase)) { throw new Error('Accès au chemin non autorisé'); } return normalizedPath;
}
import { supabaseIntegrationService } from '../supabase-integration-service';
import { GDPRAuditLogger, AuditAction } from './audit-logger';

export interface RetentionPolicy { dataType: string; retentionPeriodMonths: number; legalBasis: string; description: string; autoDelete: boolean; anonymizeInstead?: boolean;
}

export interface DataRetentionRule { id: string; tableName: string; dateField: string; policy: RetentionPolicy; lastProcessed?: Date; nextProcessing: Date;
}

/**
 * Politiques de rétention des données conformes RGPD
 */
export const RETENTION_POLICIES: Record<string, RetentionPolicy> = { // Données de commande orders: { dataType: 'Commandes et factures', retentionPeriodMonths: 120, // 10 ans pour obligations comptables legalBasis: 'legal_obligation', description: 'Conservation légale pour obligations comptables et fiscales', autoDelete: false, // Ne pas supprimer automatiquement pour obligations légales anonymizeInstead: true }, // Données utilisateur inactives inactive_users: { dataType: 'Comptes utilisateurs inactifs', retentionPeriodMonths: 36, // 3 ans d\'inactivité legalBasis: 'legitimate_interest', description: 'Suppression des comptes inactifs après 3 ans', autoDelete: true }, // Logs de navigation analytics_logs: { dataType: 'Logs d\'analyse et navigation', retentionPeriodMonths: 25, // 25 mois (recommandation CNIL) legalBasis: 'legitimate_interest', description: 'Données d\'analyse pour amélioration du service', autoDelete: true }, // Données de marketing marketing_data: { dataType: 'Données marketing et newsletters', retentionPeriodMonths: 36, // 3 ans après dernier contact legalBasis: 'consent', description: 'Données marketing avec consentement', autoDelete: true }, // Cookies et tracking tracking_data: { dataType: 'Cookies et données de suivi', retentionPeriodMonths: 13, // 13 mois maximum (CNIL) legalBasis: 'consent', description: 'Données de suivi publicitaire', autoDelete: true }, // Demandes RGPD gdpr_requests: { dataType: 'Demandes d\'exercice de droits RGPD', retentionPeriodMonths: 60, // 5 ans pour preuve de conformité legalBasis: 'legal_obligation', description: 'Conservation pour preuve de conformité RGPD', autoDelete: false }, // Logs d\'audit audit_logs: { dataType: 'Logs d\'audit sécurité', retentionPeriodMonths: 12, // 1 an minimum sécurité legalBasis: 'legitimate_interest', description: 'Logs de sécurité et audit', autoDelete: true }, // Sessions temporaires temp_sessions: { dataType: 'Sessions et données temporaires', retentionPeriodMonths: 1, // 1 mois legalBasis: 'legitimate_interest', description: 'Données de session temporaires', autoDelete: true }
};

export class DataRetentionManager { /** * Calcule la date d'expiration pour un type de données */ static calculateExpirationDate(createdAt: Date, policy: string): Date { const policy = RETENTION_POLICIES[policy]; if (!policy) { throw new Error(`Politique de rétention inconnue: ${policy}`); } const expirationDate = new Date(createdAt); expirationDate.setMonth(expirationDate.getMonth() + policy.retentionPeriodMonths); return expirationDate; } /** * Vérifie si des données ont expiré selon leur politique de rétention */ static isDataExpired(createdAt: Date, policy: string): boolean { const expirationDate = this.calculateExpirationDate(createdAt, policy); return new Date() > expirationDate; } /** * Anonymise les données sensibles d'un objet */ static anonymizeData(data: Record<string, any>): Record<string, any> { const anonymized = { ...data }; // Champs à anonymiser const sensitiveFields = [ 'email', 'firstName', 'lastName', 'phone', 'address', 'name', 'surname', 'telephone', 'adresse' ]; sensitiveFields.forEach(field => { if (anonymized[field]) { if (field === 'email') { anonymized[field] = `anonymized_${Date.now()}@example.com`; } else if (field.includes('phone') || field.includes('telephone')) { anonymized[field] = '01XXXXXXXX'; } else { anonymized[field] = '[ANONYMISÉ]'; } } }); // Marquer comme anonymisé anonymized.isAnonymized = true; anonymized.anonymizedAt = new Date(); return anonymized; } /** * Traite la rétention des données pour un type spécifique */ static async processRetentionForDataType(policy: string): Promise<{ processed: number; deleted: number; anonymized: number; errors: string[]; }> { const policy = RETENTION_POLICIES[policy]; if (!policy) { throw new Error(`Politique de rétention inconnue: ${policy}`); } const result = { processed: 0, deleted: 0, anonymized: 0, errors: [] as string[] }; try { // SECURITY: Sensitive data logging removed; // Calcul de la date limite const cutoffDate = new Date(); cutoffDate.setMonth(cutoffDate.getMonth() - policy.retentionPeriodMonths); console.log(`[DATA_RETENTION] Date limite: ${cutoffDate.toISOString()}`); // Simulation du traitement selon le type de données switch (policy) { case 'inactive_users': result.processed = await this.processInactiveUsers(cutoffDate, policy); break; case 'analytics_logs': result.processed = await this.processAnalyticsLogs(cutoffDate, policy); break; case 'marketing_data': result.processed = await this.processMarketingData(cutoffDate, policy); break; case 'orders': result.processed = await this.processOrderData(cutoffDate, policy); break; default: // SECURITY: Sensitive data logging removed; } // Log d'audit await GDPRAuditLogger.log({ action: AuditAction.DATA_RETENTION_APPLIED, resource: policy, legalBasis: policy.legalBasis, details: { policy: policy.description, cutoffDate: cutoffDate.toISOString(), processed: result.processed, deleted: result.deleted, anonymized: result.anonymized } }); } catch (error) { const errorMsg = `Erreur lors du traitement de ${policy}: ${error}`; result.errors.push(errorMsg); console.error(`[DATA_RETENTION_ERROR]`, errorMsg); } return result; } /** * Traite les utilisateurs inactifs */ private static async processInactiveUsers(cutoffDate: Date, policy: RetentionPolicy): Promise<number> { console.log(`[DATA_RETENTION] Recherche des utilisateurs inactifs depuis ${cutoffDate.toISOString()}`); // Dans un vrai projet, ceci ferait une requête en base /* const supabase = supabaseIntegrationService.getSupabaseClient(); const { data: inactiveUsers, error } = await supabase .from('users') .select('*') .or(`last_login_at.lt.${cutoffDate.toISOString()},and(last_order_at.lt.${cutoffDate.toISOString()},last_order_at.is.null)`); if (error) { throw new Error(`Erreur lors de la récupération des utilisateurs inactifs: ${error.message}`); } for (const user of inactiveUsers || []) { if (policy.autoDelete) { const { error: deleteError } = await supabase .from('users') .delete() .eq('id', user.id); if (deleteError) { console.error(`Erreur lors de la suppression de l'utilisateur ${user.id}:`, deleteError.message); } } } return inactiveUsers?.length || 0; */ // Simulation const simulatedCount = Math.floor(Math.random() * 10); console.log(`[DATA_RETENTION] ${simulatedCount} utilisateurs inactifs traités`); return simulatedCount; } /** * Traite les logs d'analytics */ private static async processAnalyticsLogs(cutoffDate: Date, policy: RetentionPolicy): Promise<number> { console.log(`[DATA_RETENTION] Suppression des logs d'analytics antérieurs à ${cutoffDate.toISOString()}`); // Simulation const simulatedCount = Math.floor(Math.random() * 1000); console.log(`[DATA_RETENTION] ${simulatedCount} logs d'analytics supprimés`); return simulatedCount; } /** * Traite les données marketing */ private static async processMarketingData(cutoffDate: Date, policy: RetentionPolicy): Promise<number> { console.log(`[DATA_RETENTION] Traitement des données marketing antérieures à ${cutoffDate.toISOString()}`); // Simulation const simulatedCount = Math.floor(Math.random() * 50); console.log(`[DATA_RETENTION] ${simulatedCount} entrées marketing traitées`); return simulatedCount; } /** * Traite les données de commande (anonymisation) */ private static async processOrderData(cutoffDate: Date, policy: RetentionPolicy): Promise<number> { console.log(`[DATA_RETENTION] Anonymisation des commandes antérieures à ${cutoffDate.toISOString()}`); // Dans un vrai projet, on anonymiserait les données sensibles /* const supabase = supabaseIntegrationService.getSupabaseClient(); const { data: oldOrders, error } = await supabase .from('orders') .select('*') .lt('created_at', cutoffDate.toISOString()) .neq('is_anonymized', true); if (error) { throw new Error(`Erreur lors de la récupération des anciennes commandes: ${error.message}`); } for (const order of oldOrders || []) { const anonymizedData = this.anonymizeData(order); const { error: updateError } = await supabase .from('orders') .update(anonymizedData) .eq('id', order.id); if (updateError) { console.error(`Erreur lors de l'anonymisation de la commande ${order.id}:`, updateError.message); } } return oldOrders?.length || 0; */ // Simulation const simulatedCount = Math.floor(Math.random() * 100); console.log(`[DATA_RETENTION] ${simulatedCount} commandes anonymisées`); return simulatedCount; } /** * Lance le processus de rétention pour tous les types de données */ static async runFullRetentionProcess(): Promise<Record<string, any>> { console.log('[DATA_RETENTION] Début du processus de rétention des données'); const results: Record<string, any> = { startTime: new Date().toISOString(), policies: {}, summary: { totalProcessed: 0, totalDeleted: 0, totalAnonymized: 0, totalErrors: 0 } }; for (const [policy, policy] of Object.entries(RETENTION_POLICIES)) { if (policy.autoDelete) { // SECURITY: Sensitive data logging removed; const policyResult = await this.processRetentionForDataType(policy); results.policies[policy] = policyResult; results.summary.totalProcessed += policyResult.processed; results.summary.totalDeleted += policyResult.deleted; results.summary.totalAnonymized += policyResult.anonymized; results.summary.totalErrors += policyResult.errors.length; } else { // SECURITY: Sensitive data logging removed; } } results.endTime = new Date().toISOString(); console.log('[DATA_RETENTION] Processus de rétention terminé:', results.summary); // Log d'audit global await GDPRAuditLogger.log({ action: AuditAction.DATA_RETENTION_APPLIED, resource: 'global_retention_process', legalBasis: 'legal_obligation', details: results }); return results; } /** * Génère un rapport de rétention des données */ static generateRetentionReport(): Record<string, any> { const report = { reportId: `RETENTION-${Date.now()}`, generatedAt: new Date().toISOString(), policies: Object.entries(RETENTION_POLICIES).map(([, policy]) => ({ policy: , dataType: policy.dataType, retentionPeriod: `${policy.retentionPeriodMonths} mois`, legalBasis: policy.legalBasis, autoDelete: policy.autoDelete, description: policy.description })), nextScheduledRun: this.getNextScheduledRun() }; console.log('[DATA_RETENTION_REPORT]', JSON.stringify(report, null, 2)); return report; } /** * Calcule la prochaine exécution programmée */ private static getNextScheduledRun(): string { const nextRun = new Date(); nextRun.setDate(nextRun.getDate() + 30); // Tous les 30 jours return nextRun.toISOString(); } /** * Vérifie si un utilisateur peut demander la suppression de ses données */ static canDeleteUserData(userId: string, userCreatedAt: Date): { canDelete: boolean; restrictions: string[]; waitUntil?: Date; } { const restrictions: string[] = []; // Vérifier les obligations légales const accountAge = Date.now() - userCreatedAt.getTime(); const oneYearMs = 365 * 24 * 60 * 60 * 1000; if (accountAge < oneYearMs) { const waitUntil = new Date(userCreatedAt.getTime() + oneYearMs); restrictions.push(`Compte créé récemment, suppression possible après ${waitUntil.toLocaleDaring('fr-FR')}`); } // Dans un vrai projet, on vérifierait : // - Commandes en cours // - Obligations comptables // - Litiges en cours // - Garanties actives return { canDelete: restrictions.length === 0, restrictions, waitUntil: restrictions.length > 0 ? new Date(userCreatedAt.getTime() + oneYearMs) : undefined }; }
}

export default DataRetentionManager;