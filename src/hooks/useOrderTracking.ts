"use client";

import { useEffect, useState, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';
import { OrderTrackingEvents } from '@/lib/socket';

interface OrderStatus { id: string; orderId: string; status: 'pending' | 'confirmed' | 'preparing' | 'cooking' | 'ready' | 'delivered' | 'cancelled'; estimatedTime?: number; actualTime?: number; updatedAt: string; message?: string; employee?: string;
}

interface OrderMessage { id: string; orderId: string; type: 'status_update' | 'info' | 'delay' | 'issue'; message: string; timestamp: string; sender: 'system' | 'employee' | 'client'; employeeName?: string; customerName?: string;
}

interface UseOrderTrackingOptions { orderId?: string; phoneNumber?: string; autoConnect?: boolean;
}

interface UseOrderTrackingReturn { isConnected: boolean; currentStatus: OrderStatus | null; messages: OrderMessage[]; connect: (orderId: string, phoneNumber: string) => void; disconnect: () => void; sendMessage: (message: string) => void; requestStatusUpdate: () => void; error: string | null;
}

export function useOrderTracking( options: UseOrderTrackingOptions = {}
): UseOrderTrackingReturn { const { orderId: initialOrderId, phoneNumber: initialPhoneNumber, autoConnect = false } = options; const [socket, setSocket] = useState<Socket | null>(null); const [isConnected, setIsConnected] = useState(false); const [currentStatus, setCurrentStatus] = useState<OrderStatus | null>(null); const [messages, setMessages] = useState<OrderMessage[]>([]); const [error, setError] = useState<string | null>(null); // Initialiser la connexion WebSocket useEffect(() => { if (autoConnect && initialOrderId && initialPhoneNumber) { connect(initialOrderId, initialPhoneNumber); } return () => { if (socket) { socket.disconnect(); } }; }, [autoConnect, initialOrderId, initialPhoneNumber]); const connect = useCallback((orderId: string, phoneNumber: string) => { try { setError(null); // Créer la connexion Socket.IO const newSocket = io(process.env.NEXT_PUBLIC_SOCKET_URL'http://localhost:3000', { transports: ['websocket', 'polling'], timeout: 10000, }); newSocket.on('connect', () => { console.log('Connected to order tracking server'); setIsConnected(true); // S'inscrire au suivi de la commande newSocket.emit('track-order', { orderId, phoneNumber }); }); newSocket.on('disconnect', () => { console.log('Disconnected from order tracking server'); setIsConnected(false); }); newSocket.on('connect_error', (err) => { console.error('Connection error:', err); setError('Erreur de connexion au serveur de suivi'); setIsConnected(false); }); // Écouter les mises à jour de statut newSocket.on('order-status-update', (data: OrderTrackingEvents['order-status-update']) => { console.log('Status update received:', data); setCurrentStatus({ id: `status-${Date.now()}`, orderId: data.orderId, status: data.status, estimatedTime: data.estimatedTime, updatedAt: data.timestamp, employee: data.employeeName }); // Ajouter un message système pour la mise à jour setMessages(prev => [...prev, { id: `msg-${Date.now()}`, orderId: data.orderId, type: 'status_update', message: `Votre commande est maintenant: ${getStatusLabel(data.status)}`, timestamp: data.timestamp, sender: 'system' }]); // Envoyer une notification browser si supporté if ('Notification' in window && Notification.permission === 'granted') { new Notification('Mise à jour O\'Miam', { body: `Votre commande est maintenant: ${getStatusLabel(data.status)}`, icon: '/favicon.ico', badge: '/favicon.ico' }); } }); // Écouter les messages newSocket.on('order-message', (data: OrderTrackingEvents['order-message']) => { console.log('Message received:', data); setMessages(prev => [...prev, { id: `msg-${Date.now()}`, orderId: data.orderId, type: data.type, message: data.message, timestamp: data.timestamp, sender: 'employee', employeeName: data.employeeName }]); // Envoyer une notification browser pour les messages importants if (data.type === 'issue' || data.type === 'delay') { if ('Notification' in window && Notification.permission === 'granted') { new Notification('Message O\'Miam', { body: data.message, icon: '/favicon.ico', badge: '/favicon.ico' }); } } }); // Écouter le statut actuel newSocket.on('current-order-status', (data: any) => { console.log('Current status received:', data); setCurrentStatus(data); }); // Écouter les notifications de commande complétée newSocket.on('order-completed', (data: OrderTrackingEvents['order-completed']) => { console.log('Order completed:', data); setMessages(prev => [...prev, { id: `msg-${Date.now()}`, orderId: data.orderId, type: 'info', message: 'Votre commande a été livrée avec succès !', timestamp: data.completionTime, sender: 'system' }]); if ('Notification' in window && Notification.permission === 'granted') { new Notification('Commande terminée O\'Miam', { body: 'Votre commande a été livrée avec succès !', icon: '/favicon.ico', badge: '/favicon.ico' }); } }); setSocket(newSocket); } catch (err) { console.error('Error connecting to order tracking:', err); setError('Erreur lors de la connexion au service de suivi'); } }, []); const disconnect = useCallback(() => { if (socket) { socket.disconnect(); setSocket(null); setIsConnected(false); setCurrentStatus(null); setMessages([]); } }, [socket]); const sendMessage = useCallback((message: string) => { if (socket && isConnected && currentStatus) { socket.emit('client-message', { orderId: currentStatus.orderId, message, customerName: 'Client', // Dans une vraie app, ceci viendrait du profil utilisateur timestamp: new Date().toISOString() }); // Ajouter le message localement pour l'affichage immédiat setMessages(prev => [...prev, { id: `msg-${Date.now()}`, orderId: currentStatus.orderId, type: 'info', message, timestamp: new Date().toISOString(), sender: 'client', customerName: 'Client' }]); } }, [socket, isConnected, currentStatus]); const requestStatusUpdate = useCallback(() => { if (socket && isConnected && currentStatus) { socket.emit('order-status-request', { orderId: currentStatus.orderId, phoneNumber: '' // Dans une vraie app, ceci viendrait du profil utilisateur }); } }, [socket, isConnected, currentStatus]); // Demander la permission de notification à la première connexion useEffect(() => { if (isConnected && 'Notification' in window && Notification.permission === 'default') { Notification.requestPermission(); } }, [isConnected]); return { isConnected, currentStatus, messages, connect, disconnect, sendMessage, requestStatusUpdate, error };
}

// Fonction utilitaire pour obtenir le libellé du statut
function getStatusLabel(status: string): string { const statusLabels = { pending: 'En attente', confirmed: 'Confirmée', preparing: 'En préparation', cooking: 'En cuisson', ready: 'Prête', delivered: 'Livrée', cancelled: 'Annulée' }; return statusLabels[status as of typeof statusLabels] || status;
}

// Hook pour les notifications push
export function useOrderNotifications() { const [permission, setPermission] = useState<NotificationPermission>('default'); useEffect(() => { if ('Notification' in window) { setPermission(Notification.permission); } }, []); const requestPermission = useCallback(async () => { if ('Notification' in window) { const result = await Notification.requestPermission(); setPermission(result); return result; } return 'denied'; }, []); const notify = useCallback((title: string, options?: NotificationOptions) => { if ('Notification' in window && permission === 'granted') { return new Notification(title, { icon: '/favicon.ico', badge: '/favicon.ico', ...options }); } return null; }, [permission]); return { permission, requestPermission, notify };
}