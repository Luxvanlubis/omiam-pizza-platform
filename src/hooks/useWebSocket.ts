"use client";

import { useEffect, useState, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

// Types pour WebSocket
interface WebSocketConfig { url?: string; options?: any; autoConnect?: boolean;
}

interface UseWebSocketReturn { socket: Socket | null; isConnected: boolean; isConnecting: boolean; error: string | null; connect: () => void; disconnect: () => void; emit: (event: string, data?: any) => void; on: (event: string, callback: (data: any) => void) => void; off: (event: string, callback?: (data: any) => void) => void;
}

// Hook personnalisé pour WebSocket
export function useWebSocket(config: WebSocketConfig = {}): UseWebSocketReturn { const { url = process.env.NEXT_PUBLIC_WEBSOCKET_URL'http://localhost:3001', options = {}, autoConnect = true } = config; const [socket, setSocket] = useState<Socket | null>(null); const [isConnected, setIsConnected] = useState(false); const [isConnecting, setIsConnecting] = useState(false); const [error, setError] = useState<string | null>(null); const socketRef = useRef<Socket | null>(null); // Fonction pour se connecter const connect = () => { if (socketRef.current?.connected) { return; } setIsConnecting(true); setError(null); try { const newSocket = io(url, { transports: ['websocket', 'polling'], timeout: 20000, forceNew: true, ...options }); // Événements de connexion newSocket.on('connect', () => { console.log('WebSocket connecté'); setIsConnected(true); setIsConnecting(false); setError(null); }); newSocket.on('disconnect', (reason) => { console.log('WebSocket déconnecté:', reason); setIsConnected(false); setIsConnecting(false); }); newSocket.on('connect_error', (err) => { console.error('Erreur de connexion WebSocket:', err); setError(err.message'Erreur de connexion'); setIsConnected(false); setIsConnecting(false); }); newSocket.on('error', (err) => { console.error('Erreur WebSocket:', err); setError(err.message'Erreur WebSocket'); }); socketRef.current = newSocket; setSocket(newSocket); } catch (err) { console.error('Erreur lors de la création du socket:', err); setError(err instanceof Error ? err.message : 'Erreur inconnue'); setIsConnecting(false); } }; // Fonction pour se déconnecter const disconnect = () => { if (socketRef.current) { socketRef.current.disconnect(); socketRef.current = null; setSocket(null); setIsConnected(false); setIsConnecting(false); } }; // Fonction pour émettre un événement const emit = (event: string, data?: any) => { if (socketRef.current?.connected) { socketRef.current.emit(event, data); } else { console.warn('Socket non connecté, impossible d\'émettre:', event); } }; // Fonction pour écouter un événement const on = (event: string, callback: (data: any) => void) => { if (socketRef.current) { socketRef.current.on(event, callback); } }; // Fonction pour arrêter d'écouter un événement const off = (event: string, callback?: (data: any) => void) => { if (socketRef.current) { if (callback) { socketRef.current.off(event, callback); } else { socketRef.current.off(event); } } }; // Effet pour la connexion automatique useEffect(() => { if (autoConnect) { connect(); } // Nettoyage à la destruction du composant return () => { disconnect(); }; }, [url, autoConnect]); // Effet pour gérer la reconnexion automatique useEffect(() => { if (!socketRef.current) return; const handleReconnect = () => { console.log('Tentative de reconnexion...'); setIsConnecting(true); }; const handleReconnectError = (err: Error) => { console.error('Erreur de reconnexion:', err); setError(err.message'Erreur de reconnexion'); setIsConnecting(false); }; const handleReconnectFailed = () => { console.error('Échec de la reconnexion'); setError('Impossible de se reconnecter'); setIsConnecting(false); }; socketRef.current.on('reconnect_attempt', handleReconnect); socketRef.current.on('reconnect_error', handleReconnectError); socketRef.current.on('reconnect_failed', handleReconnectFailed); return () => { if (socketRef.current) { socketRef.current.off('reconnect_attempt', handleReconnect); socketRef.current.off('reconnect_error', handleReconnectError); socketRef.current.off('reconnect_failed', handleReconnectFailed); } }; }, [socket]); return { socket, isConnected, isConnecting, error, connect, disconnect, emit, on, off };
}

// Hook spécialisé pour les notifications en temps réel
export function useRealtimeNotifications() { const { socket, isConnected, emit, on, off } = useWebSocket(); const [notifications, setNotifications] = useState<any[]>([]); useEffect(() => { if (!socket || !isConnected) return; // Écouter les nouvelles notifications const handleNotification = (notification: any) => { setNotifications(prev => [notification, ...prev]); }; on('notification', handleNotification); return () => { off('notification', handleNotification); }; }, [socket, isConnected, on, off]); const markAsRead = (notificationId: string) => { emit('mark-notification-read', { id: notificationId }); setNotifications(prev => prev.map(notif => notif.id === notificationId ? { ...notif, read: true } : notif ) ); }; const clearAll = () => { emit('clear-all-notifications'); setNotifications([]); }; return { notifications, markAsRead, clearAll, isConnected };
}

// Hook spécialisé pour le suivi des commandes
export function useOrderTracking(orderId?: string) { const { socket, isConnected, emit, on, off } = useWebSocket(); const [orderUpdates, setOrderUpdates] = useState<any[]>([]); useEffect(() => { if (!socket || !isConnected || !orderId) return; // S'abonner aux mises à jour de la commande emit('subscribe-order', orderId); const handleOrderUpdate = (update: any) => { if (update.orderId === orderId) { setOrderUpdates(prev => [update, ...prev]); } }; on('order-status-update', handleOrderUpdate); on('order-message', handleOrderUpdate); on('delivery-time-update', handleOrderUpdate); return () => { emit('unsubscribe-order', orderId); off('order-status-update', handleOrderUpdate); off('order-message', handleOrderUpdate); off('delivery-time-update', handleOrderUpdate); }; }, [socket, isConnected, orderId, emit, on, off]); return { orderUpdates, isConnected };
}

export default useWebSocket;